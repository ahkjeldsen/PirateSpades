<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_101 = [
   [56,17,56,74,'dccv']
, [56,17,56,74,'dccv']
, [55,17,55,18,'dccv']
, [57,17,57,70,'dccv']
, [58,13,58,14,'dccv']
, [66,17,66,54,'dccv']
, [65,17,65,18,'dccv']
, [67,17,67,60,'dccv']
, [68,13,68,14,'dccv']
, [86,17,86,136,'dccv']
, [86,17,86,136,'dccv']
, [85,17,85,18,'dccv']
, [88,17,88,52,'dccv']
, [89,13,89,14,'dccv']
, [87,17,87,88,'dccv']
, [102,17,102,70,'dccv']
, [101,17,101,18,'dccv']
, [103,17,103,100,'dccv']
, [104,13,104,14,'dccv']
, [112,17,112,70,'dccv']
, [111,17,111,18,'dccv']
, [113,17,113,116,'dccv']
, [114,13,114,14,'dccv']
, [122,17,122,102,'dccv']
, [122,17,122,102,'dccv']
, [121,17,121,18,'dccv']
, [124,17,124,52,'dccv']
, [125,17,125,38,'dccv']
, [126,17,126,45,'dccv']
, [127,17,127,24,'dccv']
, [127,36,127,47,'dccv']
, [127,25,127,32,'dccv']
, [127,49,127,50,'dccv']
, [128,21,128,65,'dccv']
, [128,66,128,67,'dccv']
, [129,25,129,38,'dccv']
, [130,25,130,48,'dccv']
, [131,21,131,22,'dccv']
, [132,17,132,18,'dccv']
, [127,33,127,35,'dccv']
, [133,17,133,31,'dccv']
, [134,13,134,14,'dccv']
, [123,17,123,69,'dccv']
, [176,9,176,22,'dccv']
, [176,23,176,24,'dccv']
, [177,13,177,64,'dccv']
, [178,13,178,60,'dccv']
, [179,13,179,34,'dccv']
, [180,13,180,53,'dccv']
, [181,13,181,30,'dccv']
, [182,13,182,29,'dccv']
, [183,13,183,28,'dccv']
, [184,13,184,32,'dccv']
, [185,9,185,10,'dccv']
, [201,13,201,107,'dccv']
, [201,13,201,107,'dccv']
, [200,39,200,40,'dccv']
, [202,13,202,39,'dccv']
, [203,9,203,10,'dccv']
, [211,13,211,107,'dccv']
, [211,13,211,107,'dccv']
, [210,52,210,53,'dccv']
, [212,13,212,36,'dccv']
, [213,13,213,33,'dccv']
, [214,13,214,34,'dccv']
, [216,13,216,45,'dccv']
, [217,18,217,28,'dccv']
, [217,55,217,56,'dccv']
, [218,17,218,57,'dccv']
, [219,17,219,55,'dccv']
, [220,13,220,14,'dccv']
, [217,50,217,53,'dccv']
, [217,29,217,48,'dccv']
, [221,13,221,43,'dccv']
, [223,13,223,29,'dccv']
, [223,30,223,31,'dccv']
, [224,17,224,33,'dccv']
, [225,13,225,14,'dccv']
, [226,9,226,10,'dccv']
, [232,13,232,41,'dccv']
, [231,31,231,32,'dccv']
, [233,13,233,37,'dccv']
, [233,38,233,57,'dccv']
, [240,13,240,40,'dccv']
, [239,32,239,33,'dccv']
, [241,13,241,28,'dccv']
, [242,13,242,23,'dccv']
, [242,24,242,25,'dccv']
, [243,17,243,48,'dccv']
, [244,17,244,51,'dccv']
, [245,17,245,57,'dccv']
, [246,17,246,50,'dccv']
, [248,17,248,27,'dccv']
, [249,17,249,42,'dccv']
, [249,43,249,62,'dccv']
, [250,13,250,14,'dccv']
, [250,20,250,21,'dccv']
, [251,17,251,32,'dccv']
, [252,17,252,31,'dccv']
, [254,9,254,10,'dccv']
, [261,13,261,56,'dccv']
, [261,13,261,56,'dccv']
, [260,48,260,49,'dccv']
, [262,13,262,36,'dccv']
, [262,37,262,54,'dccv']
, [263,13,263,51,'dccv']
, [264,9,264,10,'dccv']
, [271,13,271,70,'dccv']
, [271,13,271,70,'dccv']
, [271,13,271,70,'dccv']
, [270,51,270,52,'dccv']
, [272,13,272,39,'dccv']
, [272,40,272,60,'dccv']
, [273,13,273,57,'dccv']
, [274,13,274,50,'dccv']
, [275,9,275,10,'dccv']
, [281,50,281,51,'dccv']
, [282,13,282,38,'dccv']
, [282,39,282,58,'dccv']
, [283,9,283,10,'dccv']
, [290,13,290,95,'dccv']
, [290,13,290,95,'dccv']
, [289,46,289,47,'dccv']
, [291,13,291,56,'dccv']
, [292,13,292,34,'dccv']
, [293,9,293,10,'dccv']
, [300,13,300,60,'dccv']
, [300,13,300,60,'dccv']
, [299,61,299,62,'dccv']
, [301,13,301,51,'dccv']
, [302,13,302,20,'dccv']
, [302,36,302,60,'dccv']
, [302,115,302,116,'dccv']
, [302,22,302,32,'dccv']
, [302,118,302,119,'dccv']
, [303,17,303,60,'dccv']
, [304,13,304,14,'dccv']
, [302,33,302,35,'dccv']
, [305,13,305,50,'dccv']
, [305,51,305,72,'dccv']
, [306,9,306,10,'dccv']
, [328,13,328,41,'dccv']
, [327,36,327,37,'dccv']
, [329,13,329,33,'dccv']
, [330,13,330,34,'dccv']
, [331,9,331,10,'dccv']
, [337,13,337,41,'dccv']
, [336,38,336,39,'dccv']
, [338,13,338,33,'dccv']
, [339,13,339,20,'dccv']
, [339,35,339,51,'dccv']
, [339,21,339,31,'dccv']
, [339,53,339,54,'dccv']
, [340,17,340,54,'dccv']
, [341,13,341,14,'dccv']
, [339,32,339,34,'dccv']
, [342,13,342,62,'dccv']
, [343,9,343,10,'dccv']
, [351,13,351,90,'dccv']
, [351,13,351,90,'dccv']
, [350,52,350,53,'dccv']
, [353,13,353,44,'dccv']
, [354,9,354,10,'dccv']
, [352,13,352,65,'dccv']
, [362,13,362,47,'dccv']
, [361,45,361,46,'dccv']
, [363,13,363,52,'dccv']
, [364,9,364,10,'dccv']
, [372,13,372,51,'dccv']
, [371,49,371,50,'dccv']
, [373,13,373,56,'dccv']
, [374,9,374,10,'dccv']
, [382,13,382,82,'dccv']
, [382,13,382,82,'dccv']
, [381,47,381,48,'dccv']
, [384,13,384,40,'dccv']
, [385,9,385,10,'dccv']
, [383,13,383,59,'dccv']
, [393,13,393,90,'dccv']
, [393,13,393,90,'dccv']
, [392,51,392,52,'dccv']
, [395,13,395,65,'dccv']
, [396,9,396,10,'dccv']
, [394,13,394,59,'dccv']
, [404,13,404,106,'dccv']
, [404,13,404,106,'dccv']
, [403,42,403,43,'dccv']
, [406,13,406,38,'dccv']
, [407,9,407,10,'dccv']
, [405,13,405,64,'dccv']
, [425,73,425,74,'dccv']
, [426,13,426,87,'dccv']
, [426,13,426,87,'dccv']
, [425,73,425,74,'dccv']
, [428,13,428,56,'dccv']
, [428,165,428,168,'dccv']
, [429,9,429,10,'dccv']
, [427,13,427,82,'dccv']
, [436,13,436,95,'dccv']
, [436,13,436,95,'dccv']
, [435,57,435,58,'dccv']
, [438,13,438,58,'dccv']
, [439,9,439,10,'dccv']
, [437,13,437,82,'dccv']
, [302,60,302,115,'dccv']
, [428,56,428,62,'dccv']
, [24,9,24,57,'dccv']
, [29,9,29,57,'dccv']
, [428,74,428,101,'dccv']
, [428,165,428,166,'dccv']
, [428,101,428,125,'dccv']
, [428,140,428,165,'dccv']
, [192,13,192,48,'dcuc']
, [191,9,191,58,'dcuc']
, [191,59,191,60,'dcuc']
, [193,13,193,38,'dcuc']
, [194,9,194,10,'dcuc']
, [234,9,234,10,'dcuc']
, [253,13,253,14,'dcuc']
, [313,13,313,94,'dcuc']
, [313,13,313,94,'dcuc']
, [312,49,312,50,'dcuc']
, [314,13,314,45,'dcuc']
, [315,13,315,42,'dcuc']
, [315,43,315,44,'dcuc']
, [316,22,316,40,'dcuc']
, [316,65,316,66,'dcuc']
, [317,21,317,47,'dcuc']
, [318,17,318,18,'dcuc']
, [316,60,316,63,'dcuc']
, [316,41,316,58,'dcuc']
, [319,13,319,14,'dcuc']
, [320,13,320,40,'dcuc']
, [321,13,321,34,'dcuc']
, [322,9,322,10,'dcuc']
, [414,65,414,66,'dcuc']
, [415,13,415,81,'dcuc']
, [415,13,415,81,'dcuc']
, [414,65,414,66,'dcuc']
, [417,13,417,56,'dcuc']
, [417,114,417,116,'dcuc']
, [418,9,418,10,'dcuc']
, [416,13,416,82,'dcuc']
, [446,13,446,40,'dcuc']
, [445,73,445,74,'dcuc']
, [448,13,448,47,'dcuc']
, [448,159,448,161,'dcuc']
, [449,9,449,10,'dcuc']
, [447,13,447,99,'dcuc']
, [417,56,417,62,'dcuc']
, [448,47,448,75,'dcuc']
, [448,99,448,111,'dcuc']
, [448,122,448,159,'dcuc']
, [417,74,417,114,'dcuc']
, [417,74,417,114,'dcuc']
, [428,74,428,101,'dcuc']
, [428,165,428,166,'dcuc']
, [428,101,428,125,'dcuc']
, [428,140,428,165,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src101" class="dotCoverSource"><pre>// &lt;copyright file=&quot;Game.cs&quot;&gt;
//      ahal@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      A representation of a game in the Pirate Spades Game.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;

namespace PirateSpades.GameLogic {
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Diagnostics.Contracts;

    using PirateSpades.Misc;

    /// &lt;summary&gt;
    /// A representation of a game in the Pirate Spades Game.
    /// &lt;/summary&gt;
    public class Game {
        /// &lt;summary&gt;
        /// The minimum amount of players in a game before it can start.
        /// &lt;/summary&gt;
        public static readonly int MinPlayersInGame = 2;

        /// &lt;summary&gt;
        /// The maximum amount of lpayers in a game.
        /// &lt;/summary&gt;
        public static readonly int MaxPlayersInGame = 5;

        /// &lt;summary&gt;
        /// Players in the game.
        /// &lt;/summary&gt;
        public IList&lt;Player&gt; Players { get; private set; }

        /// &lt;summary&gt;
        /// Players in the game and their corresponding index in the Players list.
        /// &lt;/summary&gt;
        private OrderedDictionary&lt;Player, int&gt; GamePlayers { get; set; }

        /// &lt;summary&gt;
        /// Player names and their corresponding player.
        /// &lt;/summary&gt;
        private Dictionary&lt;String, Player&gt; PlayerNames { get; set; }

        /// &lt;summary&gt;
        /// The index of the Current Dealer.
        /// &lt;/summary&gt;
        public int CurrentDealer { get; private set; }

        /// &lt;summary&gt;
        /// Amount of cards to deal per player.
        /// &lt;/summary&gt;
        public int CardsToDeal{
            get {
                Contract.Requires(CurrentRound &gt; 0 &amp;&amp; Players.Count &gt; 0);
                return Card.CardsToDeal(CurrentRound, Players.Count);
            }
        }

        /// &lt;summary&gt;
        /// Amount of rounds possible.
        /// &lt;/summary&gt;
        public int RoundsPossible {
            get {
                Contract.Requires(Players.Count &gt; 0);
                return Round.RoundsPossible(Players.Count);
            }
        }

        /// &lt;summary&gt;
        /// List of rounds in the game.
        /// &lt;/summary&gt;
        public IList&lt;Round&gt; Rounds { get; set; }

        /// &lt;summary&gt;
        /// The current round number.
        /// &lt;/summary&gt;
        public int CurrentRound { get; private set; }
        
        /// &lt;summary&gt;
        /// The current round being played.
        /// &lt;/summary&gt;
        public Round Round {
            get {
                Contract.Requires(Started &amp;&amp; CurrentRound &gt;= 1 &amp;&amp; CurrentRound &lt;= RoundsPossible &amp;&amp; Players.Count &gt;= MinPlayersInGame);
                Contract.Ensures(Contract.Result&lt;Round&gt;() == Rounds[CurrentRound - 1]);
                return this.GetRound(CurrentRound);
            }
        }
        
        /// &lt;summary&gt;
        /// Whether or not the game has been started.
        /// &lt;/summary&gt;
        public bool Started { get; private set; }

        /// &lt;summary&gt;
        /// Whether ot not the game is active.
        /// &lt;/summary&gt;
        public bool Active {
            get {
                Contract.Requires(Players.Count &gt;= MinPlayersInGame);
                return Started &amp;&amp; CurrentRound &gt;= 1 &amp;&amp; CurrentRound &lt;= RoundsPossible &amp;&amp; !Finished;
            }
        }

        /// &lt;summary&gt;
        /// Whether or not the game has finished.
        /// &lt;/summary&gt;
        public bool Finished {
            get {
                Contract.Requires(Players.Count &gt;= MinPlayersInGame);
                return Started &amp;&amp; CurrentRound == RoundsPossible &amp;&amp; CurrentRound == Rounds.Count &amp;&amp; Round.Finished;
            }
        }

        /// &lt;summary&gt;
        /// The current game leader.
        /// &lt;/summary&gt;
        public Player Leader {
            get {
                Contract.Requires(Started &amp;&amp; CurrentRound &gt;= 1 &amp;&amp; Players.Count &gt;= MinPlayersInGame);
                Contract.Ensures(Contract.Result&lt;Player&gt;() != null);
                var scores = this.GetTotalScores();
                Player leader = null;
                var maxScore = int.MinValue;
                foreach(var key in scores.Keys) {
                    if(leader == null || scores[key] &gt; maxScore) {
                        leader = key;
                        maxScore = scores[key];
                    }
                }
                return leader;
            }
        }

        /// &lt;summary&gt;
        /// Whether or not the game was created by a host.
        /// &lt;/summary&gt;
        private bool IsHost { get; set; }

        /// &lt;summary&gt;
        /// Delegate to be used for events involving the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;&lt;/param&gt;
        public delegate void GameEventDelegate(Game game);

        /// &lt;summary&gt;
        /// Fires when a round has been started.
        /// &lt;/summary&gt;
        public event GameEventDelegate RoundStarted;

        /// &lt;summary&gt;
        /// Fires when a round has begun.
        /// &lt;/summary&gt;
        public event GameEventDelegate RoundBegun;

        /// &lt;summary&gt;
        /// Fires when a round has finished.
        /// &lt;/summary&gt;
        public event GameEventDelegate RoundFinished;

        /// &lt;summary&gt;
        /// Fires when a new pile has been created.
        /// &lt;/summary&gt;
        public event GameEventDelegate RoundNewPile;

        /// &lt;summary&gt;
        /// Fires when the game has finished.
        /// &lt;/summary&gt;
        public event GameEventDelegate GameFinished;

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        public Game() {
            GamePlayers = new OrderedDictionary&lt;Player, int&gt;();
            PlayerNames = new Dictionary&lt;string, Player&gt;();
            this.UpdatePlayers();
            Rounds = new List&lt;Round&gt;().AsReadOnly();
            CurrentRound = 0;
            Started = false;
            IsHost = false;
            CurrentDealer = -1;
        }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;players&quot;&gt;Players to add to the game.&lt;/param&gt;
        public Game(IEnumerable&lt;Player&gt; players) : this() {
            Contract.Requires(players != null);
            this.AddPlayers(players);
        }

        /// &lt;summary&gt;
        /// Start the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dealer&quot;&gt;The dealer for the first round.&lt;/param&gt;
        public void Start(int dealer) {
            Contract.Requires(Players.Count &gt;= MinPlayersInGame &amp;&amp; dealer &gt;= 0 &amp;&amp; dealer &lt; Players.Count);
            this.Start(false, dealer);
        }

        /// &lt;summary&gt;
        /// Start the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;isHost&quot;&gt;Whether or not the game is being started by the host.&lt;/param&gt;
        /// &lt;param name=&quot;dealer&quot;&gt;The dealer for the first round.&lt;/param&gt;
        public void Start(bool isHost, int dealer) {
            Contract.Requires(Players.Count &gt;= MinPlayersInGame &amp;&amp; dealer &gt;= 0 &amp;&amp; dealer &lt; Players.Count);
            CurrentDealer = dealer;
            this.Started = true;
            this.IsHost = isHost;

            var lRounds = new List&lt;Round&gt;();
            for (var i = 1; i &lt;= RoundsPossible; i++) {
                lRounds.Add(new Round(this, i, dealer));
                dealer = (dealer + 1) % Players.Count;
            }
            Rounds = lRounds.AsReadOnly();

            if (this.IsHost) {
                this.NewRound();
            }
        }

        /// &lt;summary&gt;
        /// Finish the game.
        /// &lt;/summary&gt;
        private void Finish() {
            Contract.Requires(Finished);
            if(GameFinished != null) GameFinished(this);
        }

        /// &lt;summary&gt;
        /// Start a new round.
        /// &lt;/summary&gt;
        public void NewRound() {
            Contract.Requires(Started);
            CurrentRound++;
            if(Active) {
                var r = GetRound(CurrentRound);
                r.RoundBegun += this.OnRoundBegun;
                r.RoundFinished += this.OnRoundFinished;
                r.NewPile += this.OnRoundNewPile;

                r.Start();
                if (RoundStarted != null) RoundStarted(this);
            } else {
                CurrentRound--;
                this.Finish();
            }
        }

        /// &lt;summary&gt;
        /// A new round has begun.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The new round.&lt;/param&gt;
        private void OnRoundBegun(Round round) {
            Contract.Requires(round != null &amp;&amp; Active);
            if (RoundBegun != null) RoundBegun(this);
            round.RoundBegun -= this.OnRoundBegun;
        }

        /// &lt;summary&gt;
        /// A round has finished.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The finished round.&lt;/param&gt;
        private void OnRoundFinished(Round round) {
            Contract.Requires(round != null &amp;&amp; (Active || Finished));
            if (RoundFinished != null) RoundFinished(this);
            round.RoundFinished -= this.OnRoundFinished;
            round.NewPile -= this.OnRoundNewPile;
        }

        /// &lt;summary&gt;
        /// A new pile has been created.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round with the new pile.&lt;/param&gt;
        private void OnRoundNewPile(Round round) {
            if (RoundNewPile != null) RoundNewPile(this);
        }

        /// &lt;summary&gt;
        /// Add a player to the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        public void AddPlayer(Player player) {
            Contract.Requires(player != null &amp;&amp; !GamePlayers.ContainsKey(player) &amp;&amp; !Started);
            GamePlayers.Add(player, GamePlayers.Count);
            this.UpdatePlayers();
        }

        /// &lt;summary&gt;
        /// Add multiple players to the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;players&quot;&gt;The players.&lt;/param&gt;
        public void AddPlayers(IEnumerable&lt;Player&gt; players) {
            Contract.Requires(players != null &amp;&amp; !Started);
            var playersBefore = GamePlayers.Count;
            foreach (var player in players.Where(player =&gt; player != null &amp;&amp; !this.GamePlayers.ContainsKey(player))) {
                GamePlayers.Add(player, GamePlayers.Count);
            }
            if(GamePlayers.Count &gt; playersBefore) this.UpdatePlayers();
        }

        /// &lt;summary&gt;
        /// Remove a player from the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player to remove.&lt;/param&gt;
        public void RemovePlayer(Player player) {
            Contract.Requires(player != null &amp;&amp; GamePlayers.ContainsKey(player) &amp;&amp; !Started);
            var index = GamePlayers[player];
            if(index + 1 &lt; Players.Count) {
                for (var i = index + 1; i &lt; Players.Count; i++) {
                    GamePlayers[Players[i]]--;
                }
            }
            GamePlayers.Remove(player);
            this.UpdatePlayers();
        }

        /// &lt;summary&gt;
        /// Clear the players.
        /// &lt;/summary&gt;
        public void ClearPlayers() {
            Contract.Requires(!Started);
            GamePlayers.Clear();
            this.UpdatePlayers();
        }

        /// &lt;summary&gt;
        /// Update the players.
        /// &lt;/summary&gt;
        private void UpdatePlayers() {
            Contract.Requires(!Started);
            PlayerNames.Clear();
            foreach(var player in GamePlayers.Keys) {
                PlayerNames.Add(player.Name, player);
            }
            Players = GamePlayers.Keys.ToList().AsReadOnly();
        }

        /// &lt;summary&gt;
        /// Get a player from a player name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerName&quot;&gt;The player name.&lt;/param&gt;
        /// &lt;returns&gt;The player with the specified player name.&lt;/returns&gt;
        public Player GetPlayer(string playerName) {
            Contract.Requires(playerName != null &amp;&amp; PlayerNames.ContainsKey(playerName));
            Contract.Ensures(Contract.Result&lt;Player&gt;() != null);
            return PlayerNames[playerName];
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified player is in the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player&lt;/param&gt;
        /// &lt;returns&gt;True if the specified player is in the game, false if not.&lt;/returns&gt;
        public bool Contains(Player player) {
            Contract.Requires(player != null);
            return GamePlayers.ContainsKey(player);
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified player is in the game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerName&quot;&gt;The player name&lt;/param&gt;
        /// &lt;returns&gt;True if the specified player is in the game, false if not.&lt;/returns&gt;
        public bool Contains(string playerName) {
            Contract.Requires(playerName != null);
            return PlayerNames.ContainsKey(playerName);
        }

        /// &lt;summary&gt;
        /// Get the index of the player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;The index of the player.&lt;/returns&gt;
        public int PlayerIndex(Player player) {
            Contract.Requires(player != null &amp;&amp; GamePlayers.ContainsKey(player));
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0);
            return GamePlayers[player];
        }

        /// &lt;summary&gt;
        /// Get the index of the player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerName&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;The index of the player.&lt;/returns&gt;
        public int PlayerIndex(string playerName) {
            Contract.Requires(playerName != null &amp;&amp; PlayerNames.ContainsKey(playerName));
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0);
            return this.PlayerIndex(this.GetPlayer(playerName));
        }

        /// &lt;summary&gt;
        /// Get the round with the specified number.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round number.&lt;/param&gt;
        /// &lt;returns&gt;The round with the specified number.&lt;/returns&gt;
        public Round GetRound(int round) {
            Contract.Requires(Started &amp;&amp; round &gt;= 1 &amp;&amp; round &lt;= RoundsPossible &amp;&amp; Rounds.Count &gt;= round);
            Contract.Ensures(Contract.Result&lt;Round&gt;() != null);
            return Rounds[round - 1];
        }

        /// &lt;summary&gt;
        /// Get the scores of a specific round.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round number.&lt;/param&gt;
        /// &lt;returns&gt;A dictionary containing the players and their round score.&lt;/returns&gt;
        public Dictionary&lt;Player, int&gt; GetRoundScore(int round) {
            Contract.Requires(Started &amp;&amp; round &gt;= 1 &amp;&amp; round &lt;= RoundsPossible);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;Player, int&gt;&gt;() != null);
            return this.Players.ToDictionary(player =&gt; player, player =&gt; this.GetRound(round).PlayerScore(player));
        }

        /// &lt;summary&gt;
        /// Get the total scores up until the specified round.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;roundNum&quot;&gt;The round number.&lt;/param&gt;
        /// &lt;returns&gt;A dictionary containing the players and their total score up until the specified round.&lt;/returns&gt;
        public Dictionary&lt;Player, int&gt; GetRoundScoreTotal(int roundNum) {
            Contract.Requires(Started &amp;&amp; roundNum &gt;= 1 &amp;&amp; roundNum &lt;= RoundsPossible);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;Player, int&gt;&gt;() != null);
            return this.Players.ToDictionary(player =&gt; player, player =&gt; this.Rounds.Where(round =&gt; round.Number &lt;= roundNum).Sum(round =&gt; round.PlayerScore(player)));
        }

        /// &lt;summary&gt;
        /// Get the total scores up until the current round.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A dictionary containing the players and their total score up until the current round.&lt;/returns&gt;
        public Dictionary&lt;Player, int&gt; GetTotalScores() {
            Contract.Requires(Started &amp;&amp; CurrentRound &gt;= 1 &amp;&amp; CurrentRound &lt;= RoundsPossible);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;Player, int&gt;&gt;() != null);
            return this.GetRoundScoreTotal(CurrentRound);
        }

        /// &lt;summary&gt;
        /// Get all the total scores for all the rounds and for all the players.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A dictionary contaning the rounds, the players and their total scores for each round.&lt;/returns&gt;
        public Dictionary&lt;int, Dictionary&lt;Player, int&gt;&gt; GetScoreTable() {
            Contract.Requires(Started);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;int, Dictionary&lt;Player, int&gt;&gt;&gt;() != null);
            return this.Rounds.Where(round =&gt; round.Number &lt;= CurrentRound).ToDictionary(round =&gt; round.Number, round =&gt; this.GetRoundScoreTotal(round.Number));
        } 
    }
}
</pre></code><script type="text/javascript">
			applyranges('src101', RANGES_101)
		</script>
	</body>
</html>