<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_108 = [
   [89,9,89,31,'dccv']
, [89,32,89,33,'dccv']
, [90,13,90,34,'dccv']
, [91,9,91,10,'dccv']
, [100,13,100,92,'dccv']
, [100,13,100,92,'dccv']
, [99,68,99,69,'dccv']
, [102,13,102,51,'dccv']
, [103,9,103,10,'dccv']
, [101,13,101,45,'dccv']
, [112,80,112,81,'dccv']
, [113,13,113,92,'dccv']
, [113,13,113,92,'dccv']
, [112,80,112,81,'dccv']
, [115,13,115,33,'dccv']
, [116,13,116,60,'dccv']
, [117,13,117,99,'dccv']
, [118,13,118,59,'dccv']
, [119,13,119,38,'dccv']
, [121,17,121,18,'dccv']
, [122,17,122,32,'dccv']
, [124,75,124,76,'dccv']
, [125,21,125,44,'dccv']
, [127,21,127,83,'dccv']
, [128,21,128,68,'dccv']
, [129,21,129,91,'dccv']
, [130,21,130,36,'dccv']
, [132,21,132,57,'dccv']
, [133,21,133,39,'dccv']
, [133,40,133,41,'dccv']
, [134,25,134,32,'dccv']
, [134,50,134,86,'dccv']
, [134,128,134,129,'dccv']
, [134,34,134,46,'dccv']
, [134,131,134,132,'dccv']
, [135,29,135,56,'dccv']
, [136,29,136,73,'dccv']
, [137,25,137,26,'dccv']
, [134,47,134,49,'dccv']
, [138,25,138,64,'dccv']
, [139,21,139,22,'dccv']
, [140,17,140,18,'dccv']
, [124,17,124,74,'dccv']
, [142,17,142,30,'dccv']
, [143,13,143,14,'dccv']
, [147,13,147,34,'dccv']
, [148,13,148,42,'dccv']
, [149,9,149,10,'dccv']
, [114,13,114,45,'dccv']
, [157,76,157,77,'dccv']
, [158,13,158,44,'dccv']
, [159,17,159,18,'dccv']
, [160,17,160,63,'dccv']
, [161,17,161,61,'dccv']
, [162,17,162,29,'dccv']
, [162,30,162,31,'dccv']
, [163,21,164,78,'dccv']
, [164,112,165,43,'dccv']
, [166,17,166,18,'dccv']
, [167,13,167,14,'dccv']
, [167,15,167,34,'dccv']
, [167,35,167,36,'dccv']
, [168,17,168,81,'dccv']
, [171,13,171,14,'dccv']
, [172,13,172,24,'dccv']
, [173,9,173,10,'dccv']
, [181,13,181,44,'dccv']
, [180,57,180,58,'dccv']
, [184,13,184,51,'dccv']
, [185,13,185,59,'dccv']
, [186,13,186,63,'dccv']
, [187,13,187,69,'dccv']
, [189,13,189,68,'dccv']
, [190,9,190,10,'dccv']
, [182,13,182,67,'dccv']
, [200,13,200,106,'dccv']
, [200,13,200,106,'dccv']
, [199,73,199,74,'dccv']
, [201,13,201,102,'dccv']
, [202,13,202,29,'dccv']
, [203,17,203,18,'dccv']
, [204,17,204,68,'dccv']
, [205,17,205,53,'dccv']
, [206,17,206,37,'dccv']
, [206,38,206,39,'dccv']
, [207,21,207,67,'dccv']
, [208,17,208,18,'dccv']
, [209,13,209,14,'dccv']
, [211,23,211,24,'dccv']
, [212,17,212,32,'dccv']
, [213,13,213,14,'dccv']
, [215,13,215,24,'dccv']
, [216,9,216,10,'dccv']
, [223,48,223,49,'dccv']
, [224,13,224,44,'dccv']
, [225,9,225,10,'dccv']
, [232,62,232,63,'dccv']
, [233,13,233,88,'dccv']
, [234,9,234,10,'dccv']
, [243,13,243,43,'dccv']
, [242,49,242,50,'dccv']
, [245,13,245,47,'dccv']
, [246,9,246,10,'dccv']
, [255,13,255,43,'dccv']
, [254,52,254,53,'dccv']
, [256,13,256,45,'dccv']
, [257,9,257,10,'dccv']
, [266,13,266,60,'dccv']
, [266,13,266,60,'dccv']
, [265,50,265,51,'dccv']
, [269,13,269,78,'dccv']
, [270,9,270,10,'dccv']
, [267,13,267,68,'dccv']
, [164,78,164,112,'dccv']
, [78,17,78,108,'dccv']
, [78,17,78,108,'dccv']
, [77,13,77,88,'dccv']
, [77,89,77,90,'dccv']
, [79,17,79,30,'dccv']
, [80,17,80,42,'dccv']
, [81,17,81,40,'dccv']
, [82,17,82,46,'dccv']
, [83,13,83,14,'dccv']
, [134,86,134,128,'dccv']
, [131,25,131,31,'dcuc']
, [135,57,135,82,'dcuc']
, [138,65,138,71,'dcuc']
, [143,15,143,34,'dcuc']
, [143,35,143,36,'dcuc']
, [144,17,144,39,'dcuc']
, [145,13,145,14,'dcuc']
, [168,82,168,83,'dcuc']
, [169,21,169,43,'dcuc']
, [170,17,170,18,'dcuc']
, [209,15,209,41,'dcuc']
, [209,42,209,43,'dcuc']
, [210,17,210,55,'dcuc']
, [211,13,211,14,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src108" class="dotCoverSource"><pre>// &lt;copyright file=&quot;PirateScanner.cs&quot;&gt;
//      ahal@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      A port scanner searching for PirateSpades games.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;

namespace PirateSpades.Network {
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Diagnostics.Contracts;
    using System.Net;
    using System.Net.Sockets;
    using System.Text.RegularExpressions;

    /// &lt;summary&gt;
    /// A port scanner searching for PirateSpades games.
    /// &lt;/summary&gt;
    public class PirateScanner {
        /// &lt;summary&gt;
        /// Whether or not a check is running.
        /// &lt;/summary&gt;
        public bool CheckRunning { get; private set; }

        /// &lt;summary&gt;
        /// Delegate to be used for events involving listening for broadcasts.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sock&quot;&gt;The socket.&lt;/param&gt;
        /// &lt;param name=&quot;ep&quot;&gt;The endpoint.&lt;/param&gt;
        /// &lt;returns&gt;A list of GameInfo objects.&lt;/returns&gt;
        private delegate IList&lt;GameInfo&gt; WaitForBroadcastDelegate(Socket sock, EndPoint ep); 

        /// &lt;summary&gt;
        /// Delegate to be used for events involving finding GameInfo.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;gameInfo&quot;&gt;GameInfo object.&lt;/param&gt;
        public delegate void GameFoundDelegate(GameInfo gameInfo);

        /// &lt;summary&gt;
        /// Fires when a game has been found.
        /// &lt;/summary&gt;
        public event GameFoundDelegate GameFound;

        /// &lt;summary&gt;
        /// GameInfo class, used for storing information about games found.
        /// &lt;/summary&gt;
        public class GameInfo {
            /// &lt;summary&gt;
            /// The IP found.
            /// &lt;/summary&gt;
            public IPAddress Ip { get; private set; }

            /// &lt;summary&gt;
            /// The game name found.
            /// &lt;/summary&gt;
            public string GameName { get; private set; }

            /// &lt;summary&gt;
            /// Amount of players in game.
            /// &lt;/summary&gt;
            public int Players { get; private set; }

            /// &lt;summary&gt;
            /// Max amount of players in game.
            /// &lt;/summary&gt;
            public int MaxPlayers { get; private set; }

            /// &lt;summary&gt;
            /// Constructor.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;ip&quot;&gt;The Ip.&lt;/param&gt;
            /// &lt;param name=&quot;gameName&quot;&gt;The game name.&lt;/param&gt;
            /// &lt;param name=&quot;players&quot;&gt;Amount of players.&lt;/param&gt;
            /// &lt;param name=&quot;maxPlayers&quot;&gt;Max amount of players.&lt;/param&gt;
            public GameInfo(IPAddress ip, string gameName, int players, int maxPlayers) {
                Contract.Requires(ip != null &amp;&amp; gameName != null &amp;&amp; players &gt;= 0 &amp;&amp; maxPlayers &gt;= players);
                this.Ip = ip;
                this.GameName = gameName;
                this.Players = players;
                this.MaxPlayers = maxPlayers;
            }
        }

        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        public PirateScanner() {
            CheckRunning = false;
        }

        /// &lt;summary&gt;
        /// Scan for games.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;port&quot;&gt;Port to listen on.&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;Timeout for the scan.&lt;/param&gt;
        /// &lt;returns&gt;A list of GameInfo objects containing information about the games.&lt;/returns&gt;
        public IList&lt;GameInfo&gt; ScanForGames(int port, int timeout) {
            Contract.Requires(!CheckRunning &amp;&amp; port &gt;= 0 &amp;&amp; port &lt;= 65535 &amp;&amp; timeout &gt;= 0);
            Contract.Ensures(!CheckRunning);
            return ScanForGames(port, timeout, 0);
        }

        /// &lt;summary&gt;
        /// Scan for games.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;port&quot;&gt;Port to listen on.&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;Timeout for the scan.&lt;/param&gt;
        /// &lt;param name=&quot;amount&quot;&gt;The amount of games to find. 0 to wait for timeout.&lt;/param&gt;
        /// &lt;returns&gt;A list of GameInfo objects containing information about the games.&lt;/returns&gt;
        public IList&lt;GameInfo&gt; ScanForGames(int port, int timeout, int amount) {
            Contract.Requires(!CheckRunning &amp;&amp; port &gt;= 0 &amp;&amp; port &lt;= 65535 &amp;&amp; timeout &gt;= 0);
            Contract.Ensures(!CheckRunning);
            CheckRunning = true;
            var games = new Dictionary&lt;string, GameInfo&gt;();
            var sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            var iep = new IPEndPoint(IPAddress.Any, port);
            var start = DateTime.Now;

            try {
                sock.Bind(iep);

                while((DateTime.Now - start).TotalMilliseconds &lt; timeout) {
                    var ep = (EndPoint)iep;

                    var del = new WaitForBroadcastDelegate(this.WaitForBroadcast);
                    var ar = del.BeginInvoke(sock, ep, null, null);
                    var maxWait = timeout - (int)(DateTime.Now - start).TotalMilliseconds;
                    if(maxWait &lt; 1)
                        break;
                    ar.AsyncWaitHandle.WaitOne(maxWait);
                    if(ar.IsCompleted) {
                        foreach (var gameInfo in del.EndInvoke(ar).Where(gameInfo =&gt; !games.ContainsKey(gameInfo.Ip.ToString()))) {
                            if (this.GameFound != null) this.GameFound(gameInfo);
                            games.Add(gameInfo.Ip.ToString(), gameInfo);
                        }
                        if(amount &gt; 0 &amp;&amp; games.Count &gt;= amount) break;
                    }
                }

                sock.Close();
            } catch(Exception ex) {
                Console.WriteLine(ex);
            }

            CheckRunning = false;
            return games.Values.ToList();
        }

        /// &lt;summary&gt;
        /// Wait for a broadcast message to be received.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sock&quot;&gt;Socket to listen on.&lt;/param&gt;
        /// &lt;param name=&quot;ep&quot;&gt;Endpoint.&lt;/param&gt;
        /// &lt;returns&gt;List of GameInfo objects found.&lt;/returns&gt;
        private IList&lt;GameInfo&gt; WaitForBroadcast(Socket sock, EndPoint ep) {
            var res = new List&lt;GameInfo&gt;();
            try {
                var buffer = new byte[sock.ReceiveBufferSize];
                var read = sock.ReceiveFrom(buffer, ref ep);
                if(read &gt; 4) {
                    res.AddRange(
                        PirateMessage.GetMessages(buffer, read).Where(msg =&gt; msg.Head == PirateMessageHead.Bcst).Select(
                            GetGameInfo));
                }
            } catch(Exception ex) {
                if(!(ex is ObjectDisposedException) &amp;&amp; !(ex is SocketException)) {
                    Console.WriteLine(ex);
                }
            }
            return res;
        }

        /// &lt;summary&gt;
        /// Get a GameInfo object from a PirateMessage.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The PirateMessage.&lt;/param&gt;
        /// &lt;returns&gt;The GameInfo object from the message.&lt;/returns&gt;
        private GameInfo GetGameInfo(PirateMessage msg) {
            Contract.Requires(msg != null);
            Contract.Ensures(Contract.Result&lt;GameInfo&gt;() != null);

            var ip = PirateMessage.GetHostIp(msg);
            var gameName = PirateMessage.GetGameName(msg);
            var players = PirateMessage.GetPlayersInGame(msg);
            var maxPlayers = PirateMessage.GetMaxPlayersInGame(msg);

            return new GameInfo(ip, gameName, players, maxPlayers);
        }

        /// &lt;summary&gt;
        /// Check if a game is hosted on the specified ip and port.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ip&quot;&gt;Ip to check on.&lt;/param&gt;
        /// &lt;param name=&quot;port&quot;&gt;Port to check on.&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;Max wait.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool CheckIp(IPAddress ip, int port, int timeout) {
            Contract.Requires(ip != null &amp;&amp; port &gt;= 0 &amp;&amp; port &lt;= 65535 &amp;&amp; timeout &gt;= 0 &amp;&amp; IsValidIp(ip));
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            var res = false;
            try {
                var ar = socket.BeginConnect(ip, port, null, null);
                ar.AsyncWaitHandle.WaitOne(timeout);
                if(socket.Connected) {
                    res = PirateClientCommands.KnockKnock(socket);
                }
            } catch (SocketException ex) {
                Console.WriteLine(&quot;Exception: &quot; + ex);
            } finally {
                socket.Close();
            }
            
            return res;
        }

        /// &lt;summary&gt;
        /// Get a local IPv4 address.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A local IPv4 address.&lt;/returns&gt;
        [Pure]
        public static IPAddress GetLocalIpV4() {
            return GetLocalIpsV4().First();
        }

        /// &lt;summary&gt;
        /// Get the local IPv4 addresses.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The local IPv4 addresses.&lt;/returns&gt;
        [Pure]
        public static IEnumerable&lt;IPAddress&gt; GetLocalIpsV4() {
            return Dns.GetHostAddresses(Dns.GetHostName()).Where(IsValidIp).Distinct();
        }

        /// &lt;summary&gt;
        /// Checks if the specified Ip is valid or not.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ip&quot;&gt;Ip to check&lt;/param&gt;
        /// &lt;returns&gt;True if the ip is valid, false if not.&lt;/returns&gt;
        [Pure]
        public static bool IsValidIp(string ip) {
            Contract.Requires(ip != null);
            const string Pattern = @&quot;^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}$&quot;;
            return Regex.IsMatch(ip, Pattern);
        }

        /// &lt;summary&gt;
        /// Checks if the specified Ip is valid or not.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ip&quot;&gt;Ip to check&lt;/param&gt;
        /// &lt;returns&gt;True if the ip is valid, false if not.&lt;/returns&gt;
        [Pure]
        public static bool IsValidIp(IPAddress ip) {
            Contract.Requires(ip != null);
            return IsValidIp(ip.ToString());
        }

        /// &lt;summary&gt;
        /// Get an Ip from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ip&quot;&gt;The ip string.&lt;/param&gt;
        /// &lt;returns&gt;The IP from the string.&lt;/returns&gt;
        [Pure]
        public static IPAddress GetIp(string ip) {
            Contract.Requires(ip != null &amp;&amp; IsValidIp(ip));
            Contract.Ensures(Contract.Result&lt;IPAddress&gt;() != null);
            const string Pattern = @&quot;^((?:[1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})$&quot;;
            return IPAddress.Parse(Regex.Match(ip, Pattern).Groups[1].Value);
        }
    }
}
</pre></code><script type="text/javascript">
			applyranges('src108', RANGES_108)
		</script>
	</body>
</html>