<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_98 = [
   [79,17,79,18,'dccv']
, [80,17,80,38,'dccv']
, [81,13,81,14,'dccv']
, [113,13,113,58,'dccv']
, [113,13,113,58,'dccv']
, [112,9,112,36,'dccv']
, [112,37,112,38,'dccv']
, [114,13,114,52,'dccv']
, [115,13,115,30,'dccv']
, [117,13,117,74,'dccv']
, [118,13,118,61,'dccv']
, [119,13,119,87,'dccv']
, [121,13,121,80,'dccv']
, [122,13,122,71,'dccv']
, [123,9,123,10,'dccv']
, [130,13,130,41,'dccv']
, [129,29,129,30,'dccv']
, [133,13,133,105,'dccv']
, [134,9,134,10,'dccv']
, [131,13,131,39,'dccv']
, [164,13,164,148,'dccv']
, [164,13,164,148,'dccv']
, [163,59,163,60,'dccv']
, [167,13,167,38,'dccv']
, [168,13,168,42,'dccv']
, [169,13,169,28,'dccv']
, [170,13,170,35,'dccv']
, [171,13,171,34,'dccv']
, [173,13,173,40,'dccv']
, [174,13,174,71,'dccv']
, [175,13,175,33,'dccv']
, [177,13,177,28,'dccv']
, [178,13,178,41,'dccv']
, [179,9,179,10,'dccv']
, [165,13,165,39,'dccv']
, [184,37,184,38,'dccv']
, [185,13,185,42,'dccv']
, [186,13,186,36,'dccv']
, [186,37,186,56,'dccv']
, [187,9,187,10,'dccv']
, [193,13,193,40,'dccv']
, [192,28,192,29,'dccv']
, [195,13,195,29,'dccv']
, [196,13,196,36,'dccv']
, [197,13,197,69,'dccv']
, [198,13,198,20,'dccv']
, [198,36,198,46,'dccv']
, [198,21,198,32,'dccv']
, [198,48,198,49,'dccv']
, [199,17,199,48,'dccv']
, [200,13,200,14,'dccv']
, [198,33,198,35,'dccv']
, [201,13,201,34,'dccv']
, [202,13,202,34,'dccv']
, [203,13,203,34,'dccv']
, [204,9,204,10,'dccv']
, [194,13,194,40,'dccv']
, [209,38,209,39,'dccv']
, [210,13,210,68,'dccv']
, [211,9,211,10,'dccv']
, [218,13,218,74,'dccv']
, [218,13,218,74,'dccv']
, [217,55,217,56,'dccv']
, [219,17,219,18,'dccv']
, [220,17,220,54,'dccv']
, [221,17,221,29,'dccv']
, [221,30,221,31,'dccv']
, [222,21,222,68,'dccv']
, [223,21,223,60,'dccv']
, [225,21,225,45,'dccv']
, [225,46,225,47,'dccv']
, [226,25,226,39,'dccv']
, [228,25,228,46,'dccv']
, [230,25,230,71,'dccv']
, [230,72,230,73,'dccv']
, [231,29,231,71,'dccv']
, [232,29,232,59,'dccv']
, [233,25,233,26,'dccv']
, [236,21,236,22,'dccv']
, [239,17,239,18,'dccv']
, [240,13,240,14,'dccv']
, [245,9,245,10,'dccv']
, [252,13,252,48,'dccv']
, [251,61,251,62,'dccv']
, [253,13,253,40,'dccv']
, [253,41,253,42,'dccv']
, [254,17,254,44,'dccv']
, [255,17,255,59,'dccv']
, [255,60,255,61,'dccv']
, [256,21,256,77,'dccv']
, [257,21,257,35,'dccv']
, [258,17,258,18,'dccv']
, [259,17,259,46,'dccv']
, [259,47,259,48,'dccv']
, [260,21,260,44,'dccv']
, [261,17,261,18,'dccv']
, [262,17,262,67,'dccv']
, [265,13,265,14,'dccv']
, [266,9,266,10,'dccv']
, [273,13,273,48,'dccv']
, [272,65,272,66,'dccv']
, [274,13,274,54,'dccv']
, [275,13,282,15,'dccv']
, [283,9,283,10,'dccv']
, [290,13,290,80,'dccv']
, [290,13,290,80,'dccv']
, [289,61,289,62,'dccv']
, [291,17,291,18,'dccv']
, [292,17,292,60,'dccv']
, [293,17,293,43,'dccv']
, [295,17,295,46,'dccv']
, [295,47,295,48,'dccv']
, [297,21,297,62,'dccv']
, [299,21,299,35,'dccv']
, [299,36,299,37,'dccv']
, [300,25,300,32,'dccv']
, [300,45,300,89,'dccv']
, [300,34,300,41,'dccv']
, [300,91,300,92,'dccv']
, [301,29,301,62,'dccv']
, [302,25,302,26,'dccv']
, [300,42,300,44,'dccv']
, [303,21,303,22,'dccv']
, [303,28,303,42,'dccv']
, [303,43,303,44,'dccv']
, [304,25,304,56,'dccv']
, [305,21,305,22,'dccv']
, [307,21,307,49,'dccv']
, [307,50,307,80,'dccv']
, [308,17,308,18,'dccv']
, [309,13,309,14,'dccv']
, [315,15,315,35,'dccv']
, [315,36,315,37,'dccv']
, [316,17,316,39,'dccv']
, [317,13,317,14,'dccv']
, [318,9,318,10,'dccv']
, [326,13,326,63,'dccv']
, [326,13,326,63,'dccv']
, [325,74,325,75,'dccv']
, [327,17,327,18,'dccv']
, [328,17,328,48,'dccv']
, [329,17,330,114,'dccv']
, [331,13,331,14,'dccv']
, [337,9,337,10,'dccv']
, [344,13,344,80,'dccv']
, [344,13,344,80,'dccv']
, [343,51,343,52,'dccv']
, [345,17,345,18,'dccv']
, [346,17,346,63,'dccv']
, [347,17,347,43,'dccv']
, [347,44,347,45,'dccv']
, [348,21,348,66,'dccv']
, [350,17,350,18,'dccv']
, [351,13,351,14,'dccv']
, [353,15,353,34,'dccv']
, [353,35,353,36,'dccv']
, [354,17,354,53,'dccv']
, [357,13,357,14,'dccv']
, [358,9,358,10,'dccv']
, [366,13,366,63,'dccv']
, [366,13,366,63,'dccv']
, [365,77,365,78,'dccv']
, [367,13,367,52,'dccv']
, [367,53,367,54,'dccv']
, [368,17,368,34,'dccv']
, [370,25,370,70,'dccv']
, [371,25,371,31,'dccv']
, [373,25,373,79,'dccv']
, [374,25,374,31,'dccv']
, [376,25,376,81,'dccv']
, [377,25,377,31,'dccv']
, [379,25,379,78,'dccv']
, [380,25,380,31,'dccv']
, [382,13,382,14,'dccv']
, [382,20,382,21,'dccv']
, [383,17,383,34,'dccv']
, [385,25,385,64,'dccv']
, [386,25,386,31,'dccv']
, [388,25,388,64,'dccv']
, [389,25,389,31,'dccv']
, [391,25,391,75,'dccv']
, [392,25,392,31,'dccv']
, [394,13,394,14,'dccv']
, [395,9,395,10,'dccv']
, [401,72,401,73,'dccv']
, [402,13,402,26,'dccv']
, [403,9,403,10,'dccv']
, [410,13,410,48,'dccv']
, [409,56,409,57,'dccv']
, [411,13,411,59,'dccv']
, [415,13,415,27,'dccv']
, [415,28,415,29,'dccv']
, [416,17,416,78,'dccv']
, [416,79,416,80,'dccv']
, [417,21,417,85,'dccv']
, [417,86,417,87,'dccv']
, [418,25,418,80,'dccv']
, [419,21,419,22,'dccv']
, [420,17,420,18,'dccv']
, [421,13,421,14,'dccv']
, [423,13,423,27,'dccv']
, [423,28,423,29,'dccv']
, [424,17,424,53,'dccv']
, [425,13,425,14,'dccv']
, [426,13,426,35,'dccv']
, [427,9,427,10,'dccv']
, [435,13,435,83,'dccv']
, [435,13,435,83,'dccv']
, [434,61,434,62,'dccv']
, [437,13,437,27,'dccv']
, [437,28,437,29,'dccv']
, [438,17,438,45,'dccv']
, [440,9,440,10,'dccv']
, [436,13,436,71,'dccv']
, [448,13,448,73,'dccv']
, [448,13,448,73,'dccv']
, [447,56,447,57,'dccv']
, [451,13,451,26,'dccv']
, [451,27,451,28,'dccv']
, [452,17,452,42,'dccv']
, [453,13,453,14,'dccv']
, [454,13,454,26,'dccv']
, [454,27,454,28,'dccv']
, [455,17,455,45,'dccv']
, [457,9,457,10,'dccv']
, [449,13,449,71,'dccv']
, [465,13,465,60,'dccv']
, [465,13,465,60,'dccv']
, [464,52,464,53,'dccv']
, [467,13,467,26,'dccv']
, [467,27,467,28,'dccv']
, [468,17,468,35,'dccv']
, [470,9,470,10,'dccv']
, [466,13,466,71,'dccv']
, [500,13,500,51,'dccv']
, [499,55,499,56,'dccv']
, [501,13,501,26,'dccv']
, [501,27,501,28,'dccv']
, [502,17,502,56,'dccv']
, [504,9,504,10,'dccv']
, [512,13,512,108,'dccv']
, [512,13,512,108,'dccv']
, [511,70,511,71,'dccv']
, [513,13,513,27,'dccv']
, [513,28,513,29,'dccv']
, [514,17,514,78,'dccv']
, [519,17,519,56,'dccv']
, [520,13,520,14,'dccv']
, [522,13,522,35,'dccv']
, [524,13,524,96,'dccv']
, [525,13,525,35,'dccv']
, [526,9,526,10,'dccv']
, [532,55,532,56,'dccv']
, [533,13,533,40,'dccv']
, [534,9,534,10,'dccv']
, [540,13,540,62,'dccv']
, [540,13,540,62,'dccv']
, [539,33,539,34,'dccv']
, [541,13,541,48,'dccv']
, [542,9,542,10,'dccv']
, [547,32,547,33,'dccv']
, [548,13,548,30,'dccv']
, [555,13,555,31,'dccv']
, [556,13,556,47,'dccv']
, [557,13,557,43,'dccv']
, [558,13,558,49,'dccv']
, [559,13,559,47,'dccv']
, [560,13,560,52,'dccv']
, [561,9,561,10,'dccv']
, [566,44,566,45,'dccv']
, [567,13,567,104,'dccv']
, [568,13,568,55,'dccv']
, [569,9,569,10,'dccv']
, [575,46,575,47,'dccv']
, [576,13,576,47,'dccv']
, [577,9,577,10,'dccv']
, [583,44,583,45,'dccv']
, [584,13,584,85,'dccv']
, [585,9,585,10,'dccv']
, [591,46,591,47,'dccv']
, [592,13,592,46,'dccv']
, [593,9,593,10,'dccv']
, [599,47,599,48,'dccv']
, [600,13,600,52,'dccv']
, [601,9,601,10,'dccv']
, [607,46,607,47,'dccv']
, [608,13,608,51,'dccv']
, [617,13,617,64,'dccv']
, [616,61,616,62,'dccv']
, [618,13,618,68,'dccv']
, [619,9,619,10,'dccv']
, [96,9,96,134,'dccv']
, [88,17,88,18,'dcuc']
, [89,17,89,129,'dcuc']
, [89,164,89,166,'dcuc']
, [90,13,90,14,'dcuc']
, [141,13,141,76,'dcuc']
, [141,13,141,76,'dcuc']
, [140,44,140,45,'dcuc']
, [144,13,144,57,'dcuc']
, [145,9,145,10,'dcuc']
, [142,13,142,39,'dcuc']
, [152,13,152,119,'dcuc']
, [152,13,152,119,'dcuc']
, [151,43,151,44,'dcuc']
, [155,13,155,94,'dcuc']
, [156,9,156,10,'dcuc']
, [153,13,153,39,'dcuc']
, [196,37,196,56,'dcuc']
, [226,40,226,115,'dcuc']
, [233,32,233,33,'dcuc']
, [234,29,234,106,'dcuc']
, [235,25,235,26,'dcuc']
, [236,28,236,29,'dcuc']
, [237,25,237,102,'dcuc']
, [238,21,238,22,'dcuc']
, [240,15,240,41,'dcuc']
, [240,42,240,43,'dcuc']
, [241,17,241,69,'dcuc']
, [241,70,241,114,'dcuc']
, [242,13,242,14,'dcuc']
, [242,15,242,35,'dcuc']
, [242,36,242,37,'dcuc']
, [243,17,243,55,'dcuc']
, [244,13,244,14,'dcuc']
, [257,36,257,168,'dcuc']
, [262,68,262,69,'dcuc']
, [263,21,263,61,'dcuc']
, [264,17,264,18,'dcuc']
, [309,15,309,41,'dcuc']
, [309,42,309,43,'dcuc']
, [310,17,310,70,'dcuc']
, [310,71,310,115,'dcuc']
, [312,17,312,60,'dcuc']
, [313,17,313,43,'dcuc']
, [314,17,314,48,'dcuc']
, [315,13,315,14,'dcuc']
, [331,15,331,40,'dcuc']
, [331,41,331,42,'dcuc']
, [332,17,332,69,'dcuc']
, [332,70,332,113,'dcuc']
, [333,17,333,48,'dcuc']
, [334,13,334,14,'dcuc']
, [334,14,334,33,'dcuc']
, [334,33,334,34,'dcuc']
, [335,17,335,39,'dcuc']
, [336,13,336,14,'dcuc']
, [351,15,351,40,'dcuc']
, [351,41,351,42,'dcuc']
, [352,17,352,69,'dcuc']
, [352,70,352,113,'dcuc']
, [353,13,353,14,'dcuc']
, [354,54,354,55,'dcuc']
, [355,21,355,43,'dcuc']
, [356,17,356,18,'dcuc']
, [402,27,402,63,'dcuc']
, [411,60,411,61,'dcuc']
, [412,17,412,24,'dcuc']
, [478,13,478,48,'dcuc']
, [477,58,477,59,'dcuc']
, [479,13,479,51,'dcuc']
, [480,9,480,10,'dcuc']
, [488,13,488,47,'dcuc']
, [487,51,487,52,'dcuc']
, [489,13,489,26,'dcuc']
, [489,27,489,28,'dcuc']
, [490,17,490,52,'dcuc']
, [492,9,492,10,'dcuc']
, [514,79,514,80,'dcuc']
, [515,21,515,85,'dcuc']
, [515,86,515,87,'dcuc']
, [516,25,516,80,'dcuc']
, [517,21,517,22,'dcuc']
, [518,17,518,18,'dcuc']
, [548,31,548,32,'dcuc']
, [549,17,549,51,'dcuc']
, [550,17,550,47,'dcuc']
, [551,17,551,53,'dcuc']
, [552,17,552,51,'dcuc']
, [553,17,553,56,'dcuc']
, [554,13,554,14,'dcuc']
, [609,9,609,10,'dcuc']
, [89,129,89,164,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src98" class="dotCoverSource"><pre>// &lt;copyright file=&quot;PirateHost.cs&quot;&gt;
//      ahal@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      A game host for the PirateSpades game.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;

namespace PirateSpades.Network {
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;
    using System.Text.RegularExpressions;

    using PirateSpades.GameLogic;
    using PirateSpades.Misc;

    /// &lt;summary&gt;
    /// A game host for the PirateSpades game.
    /// &lt;/summary&gt;
    public class PirateHost {
        /// &lt;summary&gt;
        /// The listener.
        /// &lt;/summary&gt;
        private TcpListener Listener { get; set; }

        /// &lt;summary&gt;
        /// The host ip.
        /// &lt;/summary&gt;
        public IPAddress Ip { get; private set; }

        /// &lt;summary&gt;
        /// The port to communicate on.
        /// &lt;/summary&gt;
        public int Port { get; private set; }

        /// &lt;summary&gt;
        /// Whether or not the host has been started.
        /// &lt;/summary&gt;
        public bool Started { get; private set; }

        /// &lt;summary&gt;
        /// Whether or not the host is accepting new connections.
        /// &lt;/summary&gt;
        public bool AcceptNewConnections { get; private set; }

        /// &lt;summary&gt;
        /// Whether or not debug mode is enabled.
        /// &lt;/summary&gt;
        public bool DebugMode { get; set; }

        /// &lt;summary&gt;
        /// The game of the host.
        /// &lt;/summary&gt;
        public Game Game { get; private set; }

        /// &lt;summary&gt;
        /// The game name of the host.
        /// &lt;/summary&gt;
        public string GameName { get; private set; }

        /// &lt;summary&gt;
        /// The amount of max players.
        /// &lt;/summary&gt;
        public int MaxPlayers { get; private set; }

        /// &lt;summary&gt;
        /// The broadcaster.
        /// &lt;/summary&gt;
        public PirateBroadcaster Broadcaster { get; private set; }

        /// &lt;summary&gt;
        /// The amount of players.
        /// &lt;/summary&gt;
        public int PlayerCount {
            get {
                return Players.Count;
            }
        }

        /// &lt;summary&gt;
        /// Whether or not all clients active have set a name.
        /// &lt;/summary&gt;
        public bool PlayersReady {
            get {
                return this.Clients.Count == this.Players.Count &amp;&amp; this.Clients.Count &gt; 0 &amp;&amp; this.Clients.Values.All(pclient =&gt; !String.IsNullOrEmpty(pclient.Name));
            }
        }

        /// &lt;summary&gt;
        /// Collection of socket errors to ignore.
        /// &lt;/summary&gt;
        private static readonly HashSet&lt;SocketError&gt; IgnoreSocketErrors = new HashSet&lt;SocketError&gt;() { SocketError.ConnectionReset };

        /// &lt;summary&gt;
        /// Clients and their sockets in the order they joined.
        /// &lt;/summary&gt;
        private OrderedDictionary&lt;Socket, PirateClient&gt; Clients { get; set; }

        /// &lt;summary&gt;
        /// Player names their corresponding socket.
        /// &lt;/summary&gt;
        private Dictionary&lt;string, Socket&gt; Players { get; set; }

        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;port&quot;&gt;The port to communicate over.&lt;/param&gt;
        public PirateHost(int port) {
            Contract.Requires(port &gt; 0 &amp;&amp; port &lt;= 65535);
            this.Ip = PirateScanner.GetLocalIpV4();
            this.Port = port;

            this.Clients = new OrderedDictionary&lt;Socket, PirateClient&gt;();
            this.Players = new Dictionary&lt;string, Socket&gt;();
            this.Listener = new TcpListener(new IPEndPoint(IPAddress.Any, this.Port));

            var msg = new PirateMessage(PirateMessageHead.Bcst, Ip.ToString());
            this.Broadcaster = new PirateBroadcaster(this.Port, 6250);
        }

        /// &lt;summary&gt;
        /// Start the host.
        /// Game name will be the hosting IP with dots removed.
        /// &lt;/summary&gt;
        public void Start() {
            Contract.Requires(!Started);
            Contract.Ensures(Started);

            this.Start(PirateScanner.GetLocalIpV4().ToString().Replace(&quot;.&quot;, &quot;&quot;), Game.MaxPlayersInGame);
        }

        /// &lt;summary&gt;
        /// Start the host and use the specified game name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;gameName&quot;&gt;The game name to use.&lt;/param&gt;
        public void Start(string gameName) {
            Contract.Requires(!Started &amp;&amp; !string.IsNullOrEmpty(gameName));
            Contract.Ensures(Started);

            this.Start(gameName, Game.MaxPlayersInGame);
        }

        /// &lt;summary&gt;
        /// Start the host and use the specified max players.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;maxPlayers&quot;&gt;Max amount of players in game.&lt;/param&gt;
        public void Start(int maxPlayers) {
            Contract.Requires(!Started &amp;&amp; maxPlayers &gt;= Game.MinPlayersInGame &amp;&amp; maxPlayers &lt;= Game.MaxPlayersInGame);
            Contract.Ensures(Started);

            this.Start(PirateScanner.GetLocalIpV4().ToString().Replace(&quot;.&quot;, &quot;&quot;), maxPlayers);
        }

        /// &lt;summary&gt;
        /// Start the host and use the specified game name and the max amount of players.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;gameName&quot;&gt;The game name to use.&lt;/param&gt;
        /// &lt;param name=&quot;maxPlayers&quot;&gt;Max amount of players in game.&lt;/param&gt;
        public void Start(string gameName, int maxPlayers){
            Contract.Requires(!Started &amp;&amp; IsValidGameName(gameName) &amp;&amp; maxPlayers &gt;= Game.MinPlayersInGame &amp;&amp; maxPlayers &lt;= Game.MaxPlayersInGame);
            Contract.Ensures(Started);

            this.GameName = gameName;
            this.MaxPlayers = maxPlayers;
            this.NewGame();
            this.Listener.Start();
            this.WaitForSocket();

            this.UpdateBroadcastInfo();
            Broadcaster.BroadcastExecuted += this.OnBroadcastExecuted;
            Broadcaster.Start();
            
            Started = true;
            AcceptNewConnections = true;
        }

        /// &lt;summary&gt;
        /// Stop accepting new connections.
        /// &lt;/summary&gt;
        public void StopAccepting() {
            AcceptNewConnections = false;
            if(Broadcaster.Enabled) Broadcaster.Stop();
        }

        /// &lt;summary&gt;
        /// Stop the host.
        /// &lt;/summary&gt;
        public void Stop() {
            Contract.Requires(Started);
            Contract.Ensures(!Started);
            Started = false;
            if(Broadcaster.Enabled) Broadcaster.Stop();
            var tmpClients = new List&lt;PirateClient&gt;(Clients.Values);
            foreach(var pclient in tmpClients) {
                this.SocketDisconnect(pclient);
            }
            this.Clients.Clear();
            this.Players.Clear();
            this.Listener.Stop();
        }

        /// &lt;summary&gt;
        /// Start waiting for new connections.
        /// &lt;/summary&gt;
        private void WaitForSocket() {
            this.Listener.BeginAcceptSocket(SocketConnected, this);
        }

        /// &lt;summary&gt;
        /// New connection established.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ar&quot;&gt;AsyncResult containing information about the asynchronous operation.&lt;/param&gt;
        private void SocketConnected(IAsyncResult ar) {
            Contract.Requires(ar != null &amp;&amp; ar.AsyncState is PirateHost);
            try {
                var host = (PirateHost)ar.AsyncState;
                if (Started) {
                    var client = host.Listener.EndAcceptSocket(ar);
                    var pclient = new PirateClient(client);

                    if(AcceptNewConnections) {
                        if (DebugMode) Console.WriteLine(&quot;Client connected: &quot; + client.RemoteEndPoint.ToString());

                        host.WaitForSocket(); // Wait for more
                        
                        if (!host.Clients.ContainsKey(pclient.Socket)) {
                            host.Clients.Add(pclient.Socket, pclient);
                            SocketMessageReceive(pclient);
                        } else {
                            PirateHostCommands.ErrorMessage(this, pclient, PirateError.AlreadyConnected);
                        }
                    } else {
                        PirateHostCommands.ErrorMessage(this, pclient, PirateError.NoNewConnections);
                    }
                }
            } catch (SocketException ex) {
                if(!IgnoreSocketErrors.Contains(ex.SocketErrorCode)) Console.WriteLine(&quot;SocketException: &quot; + ex);
            } catch (Exception ex) {
                Console.WriteLine(&quot;Exception: &quot; + ex);
            }
        }

        /// &lt;summary&gt;
        /// Disconnect a client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;The client to disconnect.&lt;/param&gt;
        private void SocketDisconnect(PirateClient pclient) {
            Contract.Requires(pclient != null);
            if (pclient.Socket != null) {
                this.RemoveClient(pclient);
                if (pclient.Socket.RemoteEndPoint != null) {
                    var clientIp = pclient.Socket.RemoteEndPoint.ToString();
                    if (DebugMode) Console.WriteLine(&quot;Client disconnected &quot; + (!string.IsNullOrEmpty(pclient.Name) ? &quot;[&quot; + pclient.Name + &quot;]&quot; : &quot;&quot;) + &quot;: &quot; + clientIp);
                }
                if (pclient.Socket.Connected) {
                    pclient.Socket.Close();
                }
                if(Started &amp;&amp; !string.IsNullOrEmpty(pclient.Name)) {
                    PirateHostCommands.SendPlayerInfo(this);
                }
            }
        }

        /// &lt;summary&gt;
        /// Start receiving messages from a client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;The client to receive messages from.&lt;/param&gt;
        private void SocketMessageReceive(PirateClient pclient) {
            Contract.Requires(pclient != null);
            var mobj = new PirateMessageObj(pclient);
            pclient.Socket.BeginReceive(
                    mobj.Buffer,
                    0,
                    mobj.Buffer.Length,
                    SocketFlags.None,
                    SocketMessageReceived,
                    mobj
            );
        }

        /// &lt;summary&gt;
        /// Received message from client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ar&quot;&gt;AsyncResult containing information about the asynchronous operation.&lt;/param&gt;
        private void SocketMessageReceived(IAsyncResult ar) {
            Contract.Requires(ar != null &amp;&amp; ar.AsyncState is PirateMessageObj);
            try {
                var mobj = (PirateMessageObj)ar.AsyncState;
                var pclient = mobj.Client;

                if (pclient.Socket.Connected) {

                    var read = pclient.Socket.EndReceive(ar);

                    if (read &gt;= 4) {
                        foreach (var msg in PirateMessage.GetMessages(mobj.Buffer, read)) {
                            this.HandleMessage(pclient, msg);
                        }
                    } else if (read == 0) {
                        this.SocketDisconnect(pclient);
                    }

                    if(pclient.Socket.Connected) SocketMessageReceive(pclient);
                }
            } catch (SocketException ex) {
                if (!IgnoreSocketErrors.Contains(ex.SocketErrorCode)) Console.WriteLine(&quot;SocketException: &quot; + ex);
                
                var mobj = (PirateMessageObj)ar.AsyncState;
                var pclient = mobj.Client;
                this.SocketDisconnect(pclient);
            } catch (Exception ex) {
                Console.WriteLine(ex);
            }
        }

        /// &lt;summary&gt;
        /// Send message to a client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;Client to send to.&lt;/param&gt;
        /// &lt;param name=&quot;msg&quot;&gt;Message to send.&lt;/param&gt;
        public void SendMessage(PirateClient pclient, PirateMessage msg) {
            Contract.Requires(pclient != null &amp;&amp; msg != null);
            try {
                byte[] buffer = msg.GetBytes();
                pclient.Socket.BeginSend(
                    buffer, 0, buffer.Length, SocketFlags.None, MessageSent, new PirateMessageObj(pclient, msg));
            } catch(SocketException ex) {
                if(!IgnoreSocketErrors.Contains(ex.SocketErrorCode)) Console.WriteLine(&quot;SocketException:&quot; + ex);
                this.SocketDisconnect(pclient);
            }catch(Exception ex){
                Console.WriteLine(ex);
            }
        }

        /// &lt;summary&gt;
        /// Message sent to client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ar&quot;&gt;AsyncResult containing information about the asynchronous operation.&lt;/param&gt;
        private void MessageSent(IAsyncResult ar) {
            Contract.Requires(ar != null &amp;&amp; ar.AsyncState is PirateMessageObj);
            try {
                var sendObj = (PirateMessageObj)ar.AsyncState;
                if(!sendObj.Client.IsDead) {
                    var sent = sendObj.Client.Socket.EndSend(ar);
                    // TODO: Log that the message has been sent?
                }
            } catch(SocketException ex) {
                if(!IgnoreSocketErrors.Contains(ex.SocketErrorCode)) Console.WriteLine(&quot;SocketException:&quot; + ex);
            } catch(Exception ex) {
                if(!(ex is ObjectDisposedException)) {
                    Console.WriteLine(ex);
                }
            }
        }

        /// &lt;summary&gt;
        /// Handle message received.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;Client that send the message.&lt;/param&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message.&lt;/param&gt;
        private void HandleMessage(PirateClient pclient, PirateMessage msg) {
            Contract.Requires(pclient != null &amp;&amp; msg != null);
            if (!Players.ContainsKey(pclient.Name)) {
                switch (msg.Head) {
                    case PirateMessageHead.Knck:
                        PirateHostCommands.KnockKnock(this, pclient);
                        break;
                    case PirateMessageHead.Init:
                        PirateHostCommands.InitConnection(this, pclient, msg);
                        break;
                    case PirateMessageHead.Verf:
                        PirateHostCommands.VerifyConnection(this, pclient, msg);
                        break;
                    case PirateMessageHead.Pnfo:
                        PirateHostCommands.SetPlayerInfo(this, pclient, msg);
                        break;
                }
            } else {
                switch (msg.Head) {
                    case PirateMessageHead.Xcrd:
                        PirateHostCommands.DealCard(this, msg);
                        break;
                    case PirateMessageHead.Pcrd:
                        PirateHostCommands.PlayCard(this, msg);
                        break;
                    case PirateMessageHead.Pbet:
                        PirateHostCommands.ReceiveBet(this, pclient, msg);
                        break;
                }
            }
        }

        /// &lt;summary&gt;
        /// When a broadcast has been executed.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;broadcaster&quot;&gt;The broadcaster that executed.&lt;/param&gt;
        public void OnBroadcastExecuted(PirateBroadcaster broadcaster) {
            if(DebugMode) Console.WriteLine(&quot;Broadcasted IP&quot;);
        }

        /// &lt;summary&gt;
        /// Remove a client.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;Client to be removed.&lt;/param&gt;
        public void RemoveClient(PirateClient pclient) {
            Contract.Requires(pclient != null);
            if (!this.Clients.ContainsKey(pclient.Socket)) {
                return;
            }

            lock (Players) {
                if (!String.IsNullOrEmpty(this.Clients[pclient.Socket].Name)) {
                    if (this.Players.ContainsKey(this.Clients[pclient.Socket].Name)) {
                        this.Players.Remove(this.Clients[pclient.Socket].Name);
                    }
                }
            }

            lock (Clients) {
                this.Clients.Remove(pclient.Socket);
            }
            UpdateBroadcastInfo();
        }

        /// &lt;summary&gt;
        /// Get a player from a socket.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;socket&quot;&gt;Socket to use as identifier.&lt;/param&gt;
        /// &lt;returns&gt;The player associated with the socket.&lt;/returns&gt;
        public PirateClient PlayerFromSocket(Socket socket) {
            Contract.Requires(socket != null &amp;&amp; this.Clients.ContainsKey(socket));
            Contract.Ensures(Contract.Result&lt;PirateClient&gt;() != null);
            lock (Clients) {
                return this.Clients[socket];
            }
        }

        /// &lt;summary&gt;
        /// Get a player from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;The string to use as identifier.&lt;/param&gt;
        /// &lt;returns&gt;The player associated with the string.&lt;/returns&gt;
        public PirateClient PlayerFromString(string s) {
            Contract.Requires(s != null &amp;&amp; this.Players.ContainsKey(s));
            Contract.Ensures(Contract.Result&lt;PirateClient&gt;() != null);
            Socket socket;
            lock(Players) {
                socket = this.Players[s];
            }
            lock(Clients) {
                return this.Clients[socket];
            }
        }

        /// &lt;summary&gt;
        /// Get a player from an index.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;i&quot;&gt;The index.&lt;/param&gt;
        /// &lt;returns&gt;The player at the specified index.&lt;/returns&gt;
        public PirateClient PlayerFromIndex(int i) {
            Contract.Requires(i &gt;= 0 &amp;&amp; i &lt; Clients.Count);
            Contract.Ensures(Contract.Result&lt;PirateClient&gt;() != null);
            lock(Clients) {
                return Clients[i];
            }
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified player is contained in the host player list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;Player to check for.&lt;/param&gt;
        /// &lt;returns&gt;True if the player is within, false if not.&lt;/returns&gt;
        public bool ContainsPlayer(PirateClient pclient) {
            Contract.Requires(pclient != null);
            return ContainsPlayer(pclient.Socket);
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified player is contained in the host player list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;socket&quot;&gt;Socket to check for.&lt;/param&gt;
        /// &lt;returns&gt;True if the player is within, false if not.&lt;/returns&gt;
        public bool ContainsPlayer(Socket socket) {
            Contract.Requires(socket != null);
            lock(Clients) {
                return Clients.ContainsKey(socket);
            }
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified player is contained in the host player list.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerName&quot;&gt;Player to check for.&lt;/param&gt;
        /// &lt;returns&gt;True if the player is within, false if not.&lt;/returns&gt;
        public bool ContainsPlayer(string playerName) {
            Contract.Requires(playerName != null);
            lock(Players) {
                return Players.ContainsKey(playerName);
            }
        }

        /// &lt;summary&gt;
        /// Set the name of the specified player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;The player to set the name for.&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name &lt;/param&gt;
        public void SetPlayerName(PirateClient pclient, string name) {
            Contract.Requires(pclient != null &amp;&amp; name != null &amp;&amp; this.Clients.ContainsKey(pclient.Socket));
            lock (Players) {
                if (!String.IsNullOrEmpty(this.Clients[pclient.Socket].Name)) {
                    if (this.Players.ContainsKey(this.Clients[pclient.Socket].Name)) {
                        this.Players.Remove(this.Clients[pclient.Socket].Name);
                    }
                }
                this.Players.Add(name, pclient.Socket);
            }

            pclient.SetName(name);

            Console.WriteLine(&quot;Set name for &quot; + pclient.Socket.RemoteEndPoint + &quot; to &quot; + name);
            UpdateBroadcastInfo();
        }

        /// &lt;summary&gt;
        /// Get the players.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;An enumerable of players.&lt;/returns&gt;
        public IEnumerable&lt;PirateClient&gt; GetPlayers() {
            return this.Clients.Values;
        }

        /// &lt;summary&gt;
        /// Start the game.
        /// &lt;/summary&gt;
        public void StartGame() {
            Contract.Requires(Game != null &amp;&amp; !Game.Started);
            PirateHostCommands.StartGame(this);
        }

        /// &lt;summary&gt;
        /// New game.
        /// &lt;/summary&gt;
        private void NewGame() {
            if (Game != null) {
                Game.RoundStarted -= RoundStarted;
                Game.RoundBegun -= RoundBegun;
                Game.RoundFinished -= RoundFinished;
                Game.GameFinished -= GameFinished;
                Game.RoundNewPile -= this.RoundNewPile;
            }
            Game = new Game();
            Game.RoundStarted += RoundStarted;
            Game.RoundBegun += RoundBegun;
            Game.RoundFinished += RoundFinished;
            Game.GameFinished += GameFinished;
            Game.RoundNewPile += this.RoundNewPile;
        }

        /// &lt;summary&gt;
        /// Update broadcast information.
        /// &lt;/summary&gt;
        private void UpdateBroadcastInfo() {
            var msg = new PirateMessage(PirateMessageHead.Bcst, PirateMessage.ConstructHostInfo(this));
            this.Broadcaster.Message = msg.GetBytes();
        }

        /// &lt;summary&gt;
        /// Round started.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
        private void RoundStarted(Game game) {
            PirateHostCommands.NewRound(this);
        }

        /// &lt;summary&gt;
        /// Round begun.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
        private void RoundBegun(Game game) {
            PirateHostCommands.RequestCard(this, Clients[game.Round.CurrentPlayer]);
        }

        /// &lt;summary&gt;
        /// New pile has been created.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
        private void RoundNewPile(Game game) {
            PirateHostCommands.NewPile(this);
        }

        /// &lt;summary&gt;
        /// Round finished.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
        private void RoundFinished(Game game) {
            PirateHostCommands.RoundFinished(this);
        }

        /// &lt;summary&gt;
        /// Game finished.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The game.&lt;/param&gt;
        private void GameFinished(Game game) {
            PirateHostCommands.GameFinished(this);
        }

        /// &lt;summary&gt;
        /// Whether or not the game name specified is valid.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;gameName&quot;&gt;The game name to test for.&lt;/param&gt;
        /// &lt;returns&gt;True if it is valid, false if not.&lt;/returns&gt;
        public static bool IsValidGameName(string gameName) {
            Contract.Requires(!string.IsNullOrEmpty(gameName));
            return Regex.IsMatch(gameName, @&quot;^[a-zA-Z0-9]{1,12}$&quot;);
        }
    }
}
</pre></code><script type="text/javascript">
			applyranges('src98', RANGES_98)
		</script>
	</body>
</html>