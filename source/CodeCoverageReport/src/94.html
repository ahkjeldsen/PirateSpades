<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_94 = [
   [45,13,45,61,'dccv']
, [45,13,45,61,'dccv']
, [44,9,44,83,'dccv']
, [44,84,44,85,'dccv']
, [46,9,46,10,'dccv']
, [54,13,54,45,'dccv']
, [53,9,53,66,'dccv']
, [53,67,53,68,'dccv']
, [55,13,55,30,'dccv']
, [56,13,56,30,'dccv']
, [57,9,57,10,'dccv']
, [67,13,67,90,'dccv']
, [67,13,67,90,'dccv']
, [66,83,66,84,'dccv']
, [68,13,68,54,'dccv']
, [70,17,70,18,'dccv']
, [71,17,71,72,'dccv']
, [72,17,72,36,'dccv']
, [72,37,72,38,'dccv']
, [73,21,73,35,'dccv']
, [74,48,74,49,'dccv']
, [75,25,75,37,'dccv']
, [76,25,76,76,'dccv']
, [76,77,76,78,'dccv']
, [77,29,77,41,'dccv']
, [77,42,77,43,'dccv']
, [78,33,78,73,'dccv']
, [79,33,79,79,'dccv']
, [81,33,81,77,'dccv']
, [82,29,82,30,'dccv']
, [83,29,83,46,'dccv']
, [84,25,84,26,'dccv']
, [84,32,84,33,'dccv']
, [85,29,85,35,'dccv']
, [87,21,87,22,'dccv']
, [74,21,74,47,'dccv']
, [88,17,88,18,'dccv']
, [89,13,89,14,'dccv']
, [93,13,93,29,'dccv']
, [94,9,94,10,'dccv']
, [102,63,102,64,'dccv']
, [104,13,104,86,'dccv']
, [105,9,105,10,'dccv']
, [112,34,112,35,'dccv']
, [113,13,113,80,'dccv']
, [114,13,114,84,'dccv']
, [115,13,115,48,'dccv']
, [116,13,116,33,'dccv']
, [117,13,117,32,'dccv']
, [118,13,118,24,'dccv']
, [119,9,119,10,'dccv']
, [127,54,127,55,'dccv']
, [129,13,129,80,'dccv']
, [130,9,130,10,'dccv']
, [139,13,139,47,'dccv']
, [138,68,138,69,'dccv']
, [141,13,141,46,'dccv']
, [142,9,142,10,'dccv']
, [140,13,140,65,'dccv']
, [151,13,151,47,'dccv']
, [150,72,150,73,'dccv']
, [153,13,153,52,'dccv']
, [154,9,154,10,'dccv']
, [152,13,152,65,'dccv']
, [164,13,164,63,'dccv']
, [164,13,164,63,'dccv']
, [163,78,163,79,'dccv']
, [166,13,166,43,'dccv']
, [166,44,166,45,'dccv']
, [167,17,167,46,'dccv']
, [169,13,169,56,'dccv']
, [170,9,170,10,'dccv']
, [165,13,165,65,'dccv']
, [179,13,179,45,'dccv']
, [178,65,178,66,'dccv']
, [181,13,185,61,'dccv']
, [186,9,186,10,'dccv']
, [180,13,180,65,'dccv']
, [195,13,195,45,'dccv']
, [194,63,194,64,'dccv']
, [197,13,197,42,'dccv']
, [198,9,198,10,'dccv']
, [196,13,196,65,'dccv']
, [207,13,207,118,'dccv']
, [207,13,207,118,'dccv']
, [208,13,208,144,'dccv']
, [206,62,206,63,'dccv']
, [210,13,210,128,'dccv']
, [211,9,211,10,'dccv']
, [209,13,209,68,'dccv']
, [220,13,220,45,'dccv']
, [219,65,219,66,'dccv']
, [222,13,222,50,'dccv']
, [223,9,223,10,'dccv']
, [221,13,221,65,'dccv']
, [232,13,232,115,'dccv']
, [232,13,232,115,'dccv']
, [233,13,233,144,'dccv']
, [231,61,231,62,'dccv']
, [235,13,235,104,'dccv']
, [236,9,236,10,'dccv']
, [234,13,234,65,'dccv']
, [245,13,245,70,'dccv']
, [257,13,257,45,'dccv']
, [256,63,256,64,'dccv']
, [259,13,259,43,'dccv']
, [260,9,260,10,'dccv']
, [258,13,258,65,'dccv']
, [269,13,269,134,'dccv']
, [269,13,269,134,'dccv']
, [268,63,268,64,'dccv']
, [271,13,271,121,'dccv']
, [272,9,272,10,'dccv']
, [270,13,270,65,'dccv']
, [281,13,281,44,'dccv']
, [280,73,280,74,'dccv']
, [283,13,283,45,'dccv']
, [284,13,284,20,'dccv']
, [284,32,284,118,'dccv']
, [284,21,284,28,'dccv']
, [284,120,284,121,'dccv']
, [285,17,285,44,'dccv']
, [286,13,286,14,'dccv']
, [284,29,284,31,'dccv']
, [287,13,287,24,'dccv']
, [288,9,288,10,'dccv']
, [282,13,282,74,'dccv']
, [297,13,297,45,'dccv']
, [296,66,296,67,'dccv']
, [299,13,299,49,'dccv']
, [300,9,300,10,'dccv']
, [298,13,298,65,'dccv']
, [309,13,309,151,'dccv']
, [309,13,309,151,'dccv']
, [308,63,308,64,'dccv']
, [311,13,313,142,'dccv']
, [314,9,314,10,'dccv']
, [310,13,310,110,'dccv']
, [310,13,310,110,'dccv']
, [323,13,323,45,'dccv']
, [322,69,322,70,'dccv']
, [325,13,325,52,'dccv']
, [326,9,326,10,'dccv']
, [324,13,324,65,'dccv']
, [335,13,335,154,'dccv']
, [335,13,335,154,'dccv']
, [334,66,334,67,'dccv']
, [337,13,339,145,'dccv']
, [340,9,340,10,'dccv']
, [336,13,336,110,'dccv']
, [336,13,336,110,'dccv']
, [349,13,349,47,'dccv']
, [348,64,348,65,'dccv']
, [351,13,351,68,'dccv']
, [352,9,352,10,'dccv']
, [350,13,350,65,'dccv']
, [361,13,361,44,'dccv']
, [360,80,360,81,'dccv']
, [363,13,363,53,'dccv']
, [364,13,364,20,'dccv']
, [364,32,364,123,'dccv']
, [364,21,364,28,'dccv']
, [364,125,364,126,'dccv']
, [365,17,365,71,'dccv']
, [366,13,366,14,'dccv']
, [364,29,364,31,'dccv']
, [367,13,367,24,'dccv']
, [368,9,368,10,'dccv']
, [362,13,362,82,'dccv']
, [377,13,377,58,'dccv']
, [377,13,377,58,'dccv']
, [376,62,376,63,'dccv']
, [379,13,379,38,'dccv']
, [380,9,380,10,'dccv']
, [378,13,378,65,'dccv']
, [389,13,389,126,'dccv']
, [389,13,389,126,'dccv']
, [388,55,388,56,'dccv']
, [391,13,392,121,'dccv']
, [393,9,393,10,'dccv']
, [390,13,390,91,'dccv']
, [390,13,390,91,'dccv']
, [402,13,402,45,'dccv']
, [401,59,401,60,'dccv']
, [404,13,404,38,'dccv']
, [405,9,405,10,'dccv']
, [403,13,403,65,'dccv']
, [414,13,414,122,'dccv']
, [414,13,414,122,'dccv']
, [413,59,413,60,'dccv']
, [416,13,416,111,'dccv']
, [417,9,417,10,'dccv']
, [415,13,415,65,'dccv']
, [426,13,426,47,'dccv']
, [425,69,425,70,'dccv']
, [428,13,428,54,'dccv']
, [429,9,429,10,'dccv']
, [427,13,427,65,'dccv']
, [438,13,438,131,'dccv']
, [438,13,438,131,'dccv']
, [437,67,437,68,'dccv']
, [440,13,440,120,'dccv']
, [441,9,441,10,'dccv']
, [439,13,439,65,'dccv']
, [450,13,450,47,'dccv']
, [449,61,449,62,'dccv']
, [452,13,452,53,'dccv']
, [453,9,453,10,'dccv']
, [451,13,451,65,'dccv']
, [462,13,462,132,'dccv']
, [462,13,462,132,'dccv']
, [461,59,461,60,'dccv']
, [464,13,464,119,'dccv']
, [465,9,465,10,'dccv']
, [463,13,463,65,'dccv']
, [475,13,475,106,'dccv']
, [475,13,475,106,'dccv']
, [474,79,474,80,'dccv']
, [477,13,477,93,'dccv']
, [478,9,478,10,'dccv']
, [476,13,476,65,'dccv']
, [486,72,486,73,'dccv']
, [487,13,487,46,'dccv']
, [486,72,486,73,'dccv']
, [489,13,489,53,'dccv']
, [489,89,489,100,'dccv']
, [490,9,490,10,'dccv']
, [488,13,488,72,'dccv']
, [499,13,499,44,'dccv']
, [498,82,498,83,'dccv']
, [501,13,501,53,'dccv']
, [502,13,502,20,'dccv']
, [502,32,502,127,'dccv']
, [502,21,502,28,'dccv']
, [502,129,502,130,'dccv']
, [503,17,503,71,'dccv']
, [504,13,504,14,'dccv']
, [502,29,502,31,'dccv']
, [505,13,505,24,'dccv']
, [506,9,506,10,'dccv']
, [500,13,500,82,'dccv']
, [516,13,516,47,'dccv']
, [515,77,515,78,'dccv']
, [518,13,518,65,'dccv']
, [519,9,519,10,'dccv']
, [517,13,517,65,'dccv']
, [528,13,528,47,'dccv']
, [527,92,527,93,'dccv']
, [530,13,530,41,'dccv']
, [530,81,530,92,'dccv']
, [531,9,531,10,'dccv']
, [529,13,529,72,'dccv']
, [540,13,540,44,'dccv']
, [539,82,539,83,'dccv']
, [542,13,542,53,'dccv']
, [543,13,543,20,'dccv']
, [543,32,543,125,'dccv']
, [543,21,543,28,'dccv']
, [543,127,543,128,'dccv']
, [544,17,544,71,'dccv']
, [545,13,545,14,'dccv']
, [543,29,543,31,'dccv']
, [546,13,546,24,'dccv']
, [547,9,547,10,'dccv']
, [541,13,541,82,'dccv']
, [530,41,530,81,'dccv']
, [27,9,27,45,'dccv']
, [489,53,489,89,'dccv']
, [89,15,89,34,'dcuc']
, [89,35,89,36,'dcuc']
, [90,17,90,50,'dcuc']
, [91,13,91,14,'dcuc']
, [245,13,245,70,'dcuc']
, [244,65,244,66,'dcuc']
, [247,13,247,53,'dcuc']
, [248,9,248,10,'dcuc']
, [246,13,246,65,'dcuc']
, [489,53,489,89,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src94" class="dotCoverSource"><pre>// &lt;copyright file=&quot;PirateMessage.cs&quot;&gt;
//      ahal@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      Message to be send between PirateHost and PirateClient.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;

namespace PirateSpades.Network {
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Text.RegularExpressions;

    using PirateSpades.GameLogic;

    /// &lt;summary&gt;
    /// Message to be send between PirateHost and PirateClient.
    /// &lt;/summary&gt;
    public class PirateMessage {
        /// &lt;summary&gt;
        /// The size of the buffer.
        /// &lt;/summary&gt;
        public static int BufferSize = 4096;

        /// &lt;summary&gt;
        /// The head of the message.
        /// &lt;/summary&gt;
        public PirateMessageHead Head { get; set; }

        /// &lt;summary&gt;
        /// The body of the message.
        /// &lt;/summary&gt;
        public string Body { get; set; }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;head&quot;&gt;The head to use.&lt;/param&gt;
        /// &lt;param name=&quot;body&quot;&gt;The body of the message&lt;/param&gt;
        public PirateMessage(string head, string body) : this(GetHead(head), body) {
            Contract.Requires(head != null &amp;&amp; body != null);
        }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;head&quot;&gt;The head of the message.&lt;/param&gt;
        /// &lt;param name=&quot;body&quot;&gt;The body of the message.&lt;/param&gt;
        public PirateMessage(PirateMessageHead head, string body) {
            Contract.Requires(body != null);
            this.Head = head;
            this.Body = body;
        }

        /// &lt;summary&gt;
        /// Get a list of messages from a byte buffer.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;buffer&quot;&gt;The buffer to read from.&lt;/param&gt;
        /// &lt;param name=&quot;readLen&quot;&gt;Amount of bytes that have been read and stored in the buffer.&lt;/param&gt;
        /// &lt;returns&gt;The messages parsed from the buffer.&lt;/returns&gt;
        [Pure]
        public static List&lt;PirateMessage&gt; GetMessages(byte[] buffer, int readLen) {
            Contract.Requires(buffer != null &amp;&amp; readLen &lt;= buffer.Length &amp;&amp; readLen &gt; 4);
            var messages = new List&lt;PirateMessage&gt;(); 
            
            try {
                var data = Encoding.UTF8.GetString(buffer, 0, readLen);
                if(data.Length &gt; 4) {
                    var start = 0;
                    while(start &lt; data.Length) {
                        var len = 0;
                        if(int.TryParse(data.Substring(start, 4), out len)) {
                            if(len &gt;= 4) {
                                var head = data.Substring(start + 4, 4);
                                var body = data.Substring(start + 8, len - 4);

                                messages.Add(new PirateMessage(head, body));
                            }
                            start += len + 4;
                        } else {
                            break;
                        }
                    }
                }
            } catch(Exception ex) {
                Console.WriteLine(ex.ToString());
            }

            return messages;
        }

        /// &lt;summary&gt;
        /// Get a PirateMessageHead from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;head&quot;&gt;The string to parse to a PirateMessageHead.&lt;/param&gt;
        /// &lt;returns&gt;The parsed PirateMessageHead.&lt;/returns&gt;
        [Pure]
        private static PirateMessageHead GetHead(string head) {
            PirateMessageHead pmh;
            return Enum.TryParse(head, true, out pmh) ? pmh : PirateMessageHead.Fail;
        }

        /// &lt;summary&gt;
        /// Get an byte array corresponding to the message.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The message as a byte array.&lt;/returns&gt;
        [Pure]
        public byte[] GetBytes() {
            var tmp = Encoding.UTF8.GetBytes(Head.ToString().ToUpper() + Body);
            var size = Encoding.UTF8.GetBytes(String.Format(&quot;{0:d4}&quot;, tmp.Length));
            var msg = new byte[4 + tmp.Length];
            size.CopyTo(msg, 0);
            tmp.CopyTo(msg, 4);
            return msg;
        }

        /// &lt;summary&gt;
        /// Get a PirateError from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;The string to parse to a PirateError.&lt;/param&gt;
        /// &lt;returns&gt;The parsed PirateError.&lt;/returns&gt;
        [Pure]
        public static PirateError GetError(string s) {
            PirateError err;
            return Enum.TryParse(s, true, out err) ? err : PirateError.Unknown;
        }

        /// &lt;summary&gt;
        /// Transforms a sequence of strings into one string, separated by newlines.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputs&quot;&gt;The sequence of strings to transform.&lt;/param&gt;
        /// &lt;returns&gt;The transformed string.&lt;/returns&gt;
        [Pure]
        public static string ConstructBody(params string[] inputs) {
            Contract.Requires(inputs != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return string.Join(&quot;\n&quot;, inputs);
        }

        /// &lt;summary&gt;
        /// Transforms a sequence of strings into one string, separated by newlines.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;inputs&quot;&gt;The sequence of strings to transform.&lt;/param&gt;
        /// &lt;returns&gt;The transformed string.&lt;/returns&gt;
        [Pure]
        public static string ConstructBody(IEnumerable&lt;string&gt; inputs) {
            Contract.Requires(inputs != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return ConstructBody(inputs.ToArray());
        }

        /// &lt;summary&gt;
        /// Transforms a sequence of strings into one string, separated by newlines.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;body&quot;&gt;The body to append the transformed string to.&lt;/param&gt;
        /// &lt;param name=&quot;inputs&quot;&gt;The sequence of strings to transform.&lt;/param&gt;
        /// &lt;returns&gt;The transformed string.&lt;/returns&gt;
        [Pure]
        public static string AppendBody(string body, params string[] inputs) {
            Contract.Requires(body != null &amp;&amp; inputs != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            if(string.IsNullOrEmpty(body)) {
                return ConstructBody(inputs);
            }
            return body + &quot;\n&quot; + ConstructBody(inputs);
        }

        /// &lt;summary&gt;
        /// Construct Host Information.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;The host.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructHostInfo(PirateHost host) {
            Contract.Requires(host != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return ConstructBody(
                ConstructHostIp(host),
                ConstructGameName(host),
                ConstructPlayersInGame(host.PlayerCount),
                ConstructMaxPlayersInGame(host.MaxPlayers));
        }

        /// &lt;summary&gt;
        /// Construct Host IP.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;The host.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructHostIp(PirateHost host) {
            Contract.Requires(host != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;host_ip: &quot; + host.Ip;
        }

        /// &lt;summary&gt;
        /// Get the Host Ip.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Pure]
        public static IPAddress GetHostIp(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^host_ip: [0-9.]+$&quot;, RegexOptions.Multiline));
            Contract.Requires(PirateScanner.IsValidIp(Regex.Match(msg.Body, @&quot;^host_ip: ([0-9.]+)$&quot;, RegexOptions.Multiline).Groups[1].Value));
            Contract.Ensures(Contract.Result&lt;IPAddress&gt;() != null);
            return PirateScanner.GetIp(Regex.Match(msg.Body, @&quot;^host_ip: ([0-9.]+)$&quot;, RegexOptions.Multiline).Groups[1].Value);
        }

        /// &lt;summary&gt;
        /// Construct Game Name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;The host.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructGameName(PirateHost host) {
            Contract.Requires(host != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;game_name: &quot; + host.GameName;
        }

        /// &lt;summary&gt;
        /// Get the Game Name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The Get Name.&lt;/returns&gt;
        [Pure]
        public static string GetGameName(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^game_name: .+$&quot;, RegexOptions.Multiline));
            Contract.Requires(PirateHost.IsValidGameName(Regex.Match(msg.Body, @&quot;^game_name: (.+)$&quot;, RegexOptions.Multiline).Groups[1].Value));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return Regex.Match(msg.Body, @&quot;^game_name: (.+)$&quot;, RegexOptions.Multiline).Groups[1].Value;
        }

        /// &lt;summary&gt;
        /// Construct Player Name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayerName(Player player) {
            Contract.Requires(player != null &amp;&amp; player.Name != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return ConstructPlayerName(player.Name);
        }

        /// &lt;summary&gt;
        /// Construct Player Name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The player name.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayerName(string name) {
            Contract.Requires(name != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;player_name: &quot; + name;
        }

        /// &lt;summary&gt;
        /// Get the Player Name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The Player Name.&lt;/returns&gt;
        [Pure]
        public static string GetPlayerName(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^player_name: ([a-zA-Z0-9]{3,12})$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return Regex.Match(msg.Body, @&quot;^player_name: ([a-zA-Z0-9]{3,12})$&quot;, RegexOptions.Multiline).Groups[1].Value;
        }

        /// &lt;summary&gt;
        /// Get a set of Player Names.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;A set of Player Names.&lt;/returns&gt;
        [Pure]
        public static HashSet&lt;string&gt; GetPlayerNames(PirateMessage msg) {
            Contract.Requires(msg != null);
            Contract.Ensures(Contract.Result&lt;HashSet&lt;string&gt;&gt;() != null);
            var res = new HashSet&lt;string&gt;();
            foreach(Match m in Regex.Matches(msg.Body, @&quot;^player_name: ([a-zA-Z0-9]{3,12})$&quot;, RegexOptions.Multiline)) {
                res.Add(m.Groups[1].Value);
            }
            return res;
        }

        /// &lt;summary&gt;
        /// Construct Players In Game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;players&quot;&gt;The amount of players in game.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayersInGame(int players) {
            Contract.Requires(players &gt;= 0);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;players_ingame: &quot; + players;
        }
        
        /// &lt;summary&gt;
        /// Get amount of players in game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;Amount of players in game.&lt;/returns&gt;
        [Pure]
        public static int GetPlayersInGame(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^players_ingame: [0-&quot; + Game.MaxPlayersInGame + &quot;]$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0 &amp;&amp; Contract.Result&lt;int&gt;() &lt;= Game.MaxPlayersInGame);
            return
                int.Parse(
                    Regex.Match(msg.Body, @&quot;^players_ingame: ([0-&quot; + Game.MaxPlayersInGame + &quot;])$&quot;, RegexOptions.Multiline).Groups[1].Value);
        }

        /// &lt;summary&gt;
        /// Construct Max Players In Game
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;players&quot;&gt;Max amount of players in game.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructMaxPlayersInGame(int players) {
            Contract.Requires(players &gt;= 0);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;players_ingamemax: &quot; + players;
        }

        /// &lt;summary&gt;
        /// Get max amount of players allowed in game.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;Max amount of players allowed in game&lt;/returns&gt;
        [Pure]
        public static int GetMaxPlayersInGame(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^players_ingamemax: [0-&quot; + Game.MaxPlayersInGame + &quot;]$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0 &amp;&amp; Contract.Result&lt;int&gt;() &lt;= Game.MaxPlayersInGame);
            return
                int.Parse(
                    Regex.Match(msg.Body, @&quot;^players_ingamemax: ([0-&quot; + Game.MaxPlayersInGame + &quot;])$&quot;, RegexOptions.Multiline).Groups[1].Value);
        }

        /// &lt;summary&gt;
        /// Construct Player Bet.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayerBet(Player player) {
            Contract.Requires(player != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;player_bet: &quot; + player.Name + &quot;;&quot; + player.Bet;
        }

        /// &lt;summary&gt;
        /// Get the bets of the players.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;A dictionary of player names and the amount they betted.&lt;/returns&gt;
        [Pure]
        public static Dictionary&lt;string, int&gt; GetPlayerBets(PirateMessage msg) {
            Contract.Requires(msg != null);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;string, int&gt;&gt;() != null);
            var res = new Dictionary&lt;string, int&gt;();
            foreach(Match m in Regex.Matches(msg.Body, @&quot;^player_bet: ([a-zA-Z0-9]+);(10|[0-9])$&quot;, RegexOptions.Multiline)) {
                res[m.Groups[1].Value] = int.Parse(m.Groups[2].Value);
            }
            return res;
        }

        /// &lt;summary&gt;
        /// Construct Round Number.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructRoundNumber(int round) {
            Contract.Requires(round &gt;= 1 &amp;&amp; round &lt;= 20);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;round: &quot; + round;
        }

        /// &lt;summary&gt;
        /// Get the Round Number.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The Round Number&lt;/returns&gt;
        [Pure]
        public static int GetRound(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^round: ([1-9]|1[0-9]|20)$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 1 &amp;&amp; Contract.Result&lt;int&gt;() &lt;= 20);
            return
                int.Parse(Regex.Match(msg.Body, @&quot;^round: ([1-9]|1[0-9]|20)$&quot;, RegexOptions.Multiline).Groups[1].Value);
        }

        /// &lt;summary&gt;
        /// Construct Dealer.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the dealer.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructDealer(string name) {
            Contract.Requires(name != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;dealer: &quot; + name;
        }

        /// &lt;summary&gt;
        /// Get the Dealer.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The Dealer.&lt;/returns&gt;
        [Pure]
        public static string GetDealer(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^dealer: [a-zA-Z0-9]+$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return Regex.Match(msg.Body, @&quot;^dealer: ([a-zA-Z0-9]+)$&quot;, RegexOptions.Multiline).Groups[1].Value;
        }

        /// &lt;summary&gt;
        /// Construct Starting Player-
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructStartingPlayer(Player player) {
            Contract.Requires(player != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;starting_player: &quot; + player.Name;
        }

        /// &lt;summary&gt;
        /// Get the name of Starting Player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The name of the Starting Player.&lt;/returns&gt;
        [Pure]
        public static string GetStartingPlayer(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^starting_player: [a-zA-Z0-9]+$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return Regex.Match(msg.Body, @&quot;^starting_player: ([a-zA-Z0-9]+)$&quot;, RegexOptions.Multiline).Groups[1].Value;
        }

        /// &lt;summary&gt;
        /// Construct Winner.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructWinner(Player player) {
            Contract.Requires(player != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;winning_player: &quot; + player.Name;
        }

        /// &lt;summary&gt;
        /// Get the name of the Winner.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;The name of the Winner.&lt;/returns&gt;
        [Pure]
        public static string GetWinner(PirateMessage msg) {
            Contract.Requires(msg != null &amp;&amp; Regex.IsMatch(msg.Body, @&quot;^winning_player: [a-zA-Z0-9]\w+$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return Regex.Match(msg.Body, @&quot;^winning_player: ([a-zA-Z0-9]+)$&quot;, RegexOptions.Multiline).Groups[1].Value;
        }

        /// &lt;summary&gt;
        /// Construct Player Trick.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round.&lt;/param&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayerTrick(Round round, Player player) {
            Contract.Requires(round != null &amp;&amp; player != null &amp;&amp; round.PlayerTricks.ContainsKey(player));
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;player_tricks: &quot; + player.Name + &quot;;&quot; + round.PlayerTricks[player].Count;
        }

        /// &lt;summary&gt;
        /// Construct Player Tricks.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round.&lt;/param&gt;
        /// &lt;returns&gt;A list of strings to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static IList&lt;string&gt; ConstructPlayerTricks(Round round) {
            Contract.Requires(round != null);
            Contract.Ensures(Contract.Result&lt;IList&lt;string&gt;&gt;() != null);
            return round.PlayerTricks.Select(kvp =&gt; ConstructPlayerTrick(round, kvp.Key)).ToList();
        }

        /// &lt;summary&gt;
        /// Get a dictionary of player names and the amount of tricks they have.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;A dictionary of player names and the amount of tricks they have.&lt;/returns&gt;
        [Pure]
        public static Dictionary&lt;string, int&gt; GetPlayerTricks(PirateMessage msg) {
            Contract.Requires(msg != null);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;string, int&gt;&gt;() != null);
            var res = new Dictionary&lt;string, int&gt;();
            foreach(Match m in Regex.Matches(msg.Body, @&quot;^player_tricks: ([a-zA-Z0-9]+);(10|[0-9]+)$&quot;, RegexOptions.Multiline)) {
                res[m.Groups[1].Value] = int.Parse(m.Groups[2].Value);
            }
            return res;
        }

        /// &lt;summary&gt;
        /// Construct Player score.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The player.&lt;/param&gt;
        /// &lt;param name=&quot;score&quot;&gt;The score.&lt;/param&gt;
        /// &lt;returns&gt;A string to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static string ConstructPlayerScore(Player player, int score) {
            Contract.Requires(player != null);
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;player_score: &quot; + player.Name + &quot;;&quot; + score;
        }

        /// &lt;summary&gt;
        /// Construct Player Scores.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;scores&quot;&gt;A dictionary of players and their scores.&lt;/param&gt;
        /// &lt;returns&gt;A list of strings to be used when sending messages.&lt;/returns&gt;
        [Pure]
        public static IList&lt;string&gt; ContstructPlayerScores(Dictionary&lt;Player, int&gt; scores) {
            Contract.Requires(scores != null);
            Contract.Ensures(Contract.Result&lt;IList&lt;string&gt;&gt;() != null);
            return scores.Select(kvp =&gt; ConstructPlayerScore(kvp.Key, kvp.Value)).ToList();
        }

        /// &lt;summary&gt;
        /// Get a dictionary of player names and their current game score.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to get from.&lt;/param&gt;
        /// &lt;returns&gt;A dictionary of player names and their current game score.&lt;/returns&gt;
        [Pure]
        public static Dictionary&lt;string, int&gt; GetPlayerScores(PirateMessage msg) {
            Contract.Requires(msg != null);
            Contract.Ensures(Contract.Result&lt;Dictionary&lt;string, int&gt;&gt;() != null);
            var res = new Dictionary&lt;string, int&gt;();
            foreach(Match m in Regex.Matches(msg.Body, @&quot;^player_score: ([a-zA-Z0-9]+);(-?[0-9]+)$&quot;, RegexOptions.Multiline)) {
                res[m.Groups[1].Value] = int.Parse(m.Groups[2].Value);
            }
            return res;
        }
    }

    public enum PirateMessageHead {
        /// &lt;summary&gt;Failure&lt;/summary&gt;
        Fail, // Failure

        /// &lt;summary&gt;Error&lt;/summary&gt;
        Erro,

        /// &lt;summary&gt;Knock Knock (For scanning)&lt;/summary&gt;
        Knck,

        /// &lt;summary&gt;Broadcast&lt;/summary&gt;
        Bcst,

        /// &lt;summary&gt;Init Player Connection&lt;/summary&gt;
        Init,

        /// &lt;summary&gt;Verify&lt;/summary&gt;
        Verf,

        /// &lt;summary&gt;Player Information&lt;/summary&gt;
        Pnfo,

        /// &lt;summary&gt;Players In Game&lt;/summary&gt;
        Pigm, 

        /// &lt;summary&gt;Player Accept&lt;/summary&gt;
        Pacp,

        /// &lt;summary&gt;Game Started&lt;/summary&gt;
        Gstr,

        /// &lt;summary&gt;Game Finished&lt;/summary&gt;
        Gfin,

        /// &lt;summary&gt;Transfer Card&lt;/summary&gt;
        Xcrd,

        /// &lt;summary&gt;Play Card&lt;/summary&gt;
        Pcrd,

        /// &lt;summary&gt;Trick Done&lt;/summary&gt;
        Trdn,

        /// &lt;summary&gt;Player Bet&lt;/summary&gt;
        Pbet,

        /// &lt;summary&gt;New Round&lt;/summary&gt;
        Nrnd,

        /// &lt;summary&gt;Begin Round&lt;/summary&gt;
        Bgrn,

        /// &lt;summary&gt;Finish Round&lt;/summary&gt;
        Frnd,

        /// &lt;summary&gt;Done Dealing Cards&lt;/summary&gt;
        Ddlc,

        /// &lt;summary&gt;Request Bets&lt;/summary&gt;
        Breq,

        /// &lt;summary&gt;Request Card&lt;/summary&gt;
        Creq
    }

    public enum PirateError {
        /// &lt;summary&gt;Unknown error. Also used if error send could not be identified.&lt;/summary&gt;
        Unknown,

        /// &lt;summary&gt;You&#39;re already connected.&lt;/summary&gt;
        AlreadyConnected,

        /// &lt;summary&gt;No new connection allowed.&lt;/summary&gt;
        NoNewConnections,

        /// &lt;summary&gt;The name the user wanted to use was already taken.&lt;/summary&gt;
        NameAlreadyTaken,

        /// &lt;summary&gt;Invalid bet.&lt;/summary&gt;
        InvalidBet,

        /// &lt;summary&gt;Card not playable.&lt;/summary&gt;
        CardNotPlayable
    }
}</pre></code><script type="text/javascript">
			applyranges('src94', RANGES_94)
		</script>
	</body>
</html>