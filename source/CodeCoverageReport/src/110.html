<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_110 = [
   [83,13,83,47,'dccv']
, [82,9,82,55,'dccv']
, [82,56,82,57,'dccv']
, [84,13,84,34,'dccv']
, [85,13,85,39,'dccv']
, [86,13,86,25,'dccv']
, [87,9,87,10,'dccv']
, [96,13,96,119,'dccv']
, [96,13,96,119,'dccv']
, [95,9,95,78,'dccv']
, [95,79,95,80,'dccv']
, [97,13,97,40,'dccv']
, [98,13,98,25,'dccv']
, [99,13,99,103,'dccv']
, [100,17,100,18,'dccv']
, [101,17,101,47,'dccv']
, [102,17,102,42,'dccv']
, [102,43,102,44,'dccv']
, [103,21,103,49,'dccv']
, [104,17,104,18,'dccv']
, [107,13,107,14,'dccv']
, [107,15,107,40,'dccv']
, [107,41,107,42,'dccv']
, [108,17,108,63,'dccv']
, [109,17,109,31,'dccv']
, [110,13,110,14,'dccv']
, [111,9,111,10,'dccv']
, [120,13,120,119,'dccv']
, [120,13,120,119,'dccv']
, [119,9,119,103,'dccv']
, [119,104,119,105,'dccv']
, [121,9,121,10,'dccv']
, [126,29,126,30,'dccv']
, [127,13,127,28,'dccv']
, [128,13,128,51,'dccv']
, [129,13,129,32,'dccv']
, [129,33,129,34,'dccv']
, [130,17,130,54,'dccv']
, [131,17,131,52,'dccv']
, [132,17,132,46,'dccv']
, [133,13,133,14,'dccv']
, [134,9,134,10,'dccv']
, [139,38,139,39,'dccv']
, [140,13,140,55,'dccv']
, [141,9,141,10,'dccv']
, [146,34,146,35,'dccv']
, [147,13,147,38,'dccv']
, [147,39,147,40,'dccv']
, [148,17,148,37,'dccv']
, [149,17,149,31,'dccv']
, [150,13,150,14,'dccv']
, [151,13,151,37,'dccv']
, [151,38,151,39,'dccv']
, [152,17,152,36,'dccv']
, [153,13,153,14,'dccv']
, [154,9,154,10,'dccv']
, [160,46,160,47,'dccv']
, [161,13,161,55,'dccv']
, [162,9,162,10,'dccv']
, [169,52,169,53,'dccv']
, [170,13,170,55,'dccv']
, [171,9,171,10,'dccv']
, [177,40,177,41,'dccv']
, [178,13,178,52,'dccv']
, [179,9,179,10,'dccv']
, [186,13,186,45,'dccv']
, [185,42,185,43,'dccv']
, [187,13,187,30,'dccv']
, [188,13,188,31,'dccv']
, [191,9,191,10,'dccv']
, [196,45,196,46,'dccv']
, [197,13,197,51,'dccv']
, [198,13,205,15,'dccv']
, [206,9,206,10,'dccv']
, [213,13,213,80,'dccv']
, [213,13,213,80,'dccv']
, [212,61,212,62,'dccv']
, [214,17,214,18,'dccv']
, [215,17,215,60,'dccv']
, [217,17,217,38,'dccv']
, [217,39,217,40,'dccv']
, [218,21,218,54,'dccv']
, [220,21,220,35,'dccv']
, [220,36,220,37,'dccv']
, [221,25,221,32,'dccv']
, [221,45,221,89,'dccv']
, [221,34,221,41,'dccv']
, [221,91,221,92,'dccv']
, [222,29,222,53,'dccv']
, [223,25,223,26,'dccv']
, [221,42,221,44,'dccv']
, [224,21,224,22,'dccv']
, [224,28,224,42,'dccv']
, [224,43,224,44,'dccv']
, [225,25,225,43,'dccv']
, [226,21,226,22,'dccv']
, [228,21,228,42,'dccv']
, [228,43,228,66,'dccv']
, [229,17,229,18,'dccv']
, [230,13,230,14,'dccv']
, [230,14,230,39,'dccv']
, [230,40,230,41,'dccv']
, [231,17,231,69,'dccv']
, [232,17,232,35,'dccv']
, [233,13,233,14,'dccv']
, [236,9,236,10,'dccv']
, [243,13,243,44,'dccv']
, [242,52,242,53,'dccv']
, [244,13,244,41,'dccv']
, [245,13,245,92,'dccv']
, [246,9,246,10,'dccv']
, [253,13,253,77,'dccv']
, [253,13,253,77,'dccv']
, [252,51,252,52,'dccv']
, [254,13,254,43,'dccv']
, [255,13,255,52,'dccv']
, [257,9,257,10,'dccv']
, [263,55,263,56,'dccv']
, [264,13,264,29,'dccv']
, [269,21,269,70,'dccv']
, [270,21,270,27,'dccv']
, [272,21,272,52,'dccv']
, [274,28,274,29,'dccv']
, [275,25,275,67,'dccv']
, [276,21,276,22,'dccv']
, [277,21,277,27,'dccv']
, [279,21,279,61,'dccv']
, [280,21,280,27,'dccv']
, [282,21,282,67,'dccv']
, [283,21,283,27,'dccv']
, [285,21,285,70,'dccv']
, [286,21,286,27,'dccv']
, [288,21,288,65,'dccv']
, [289,21,289,27,'dccv']
, [294,21,294,61,'dccv']
, [295,21,295,27,'dccv']
, [297,21,297,62,'dccv']
, [298,21,298,27,'dccv']
, [300,21,300,64,'dccv']
, [301,21,301,27,'dccv']
, [303,21,303,65,'dccv']
, [304,21,304,27,'dccv']
, [306,21,306,39,'dccv']
, [307,21,307,27,'dccv']
, [309,21,309,40,'dccv']
, [310,21,310,27,'dccv']
, [312,9,312,10,'dccv']
, [317,34,317,35,'dccv']
, [318,13,318,37,'dccv']
, [318,38,318,57,'dccv']
, [319,9,319,10,'dccv']
, [324,35,324,36,'dccv']
, [325,13,325,39,'dccv']
, [325,40,325,60,'dccv']
, [326,9,326,10,'dccv']
, [335,43,335,44,'dccv']
, [337,13,337,60,'dccv']
, [338,9,338,10,'dccv']
, [336,13,336,65,'dccv']
, [76,9,76,134,'dccv']
, [104,23,104,24,'dcuc']
, [105,21,105,35,'dcuc']
, [106,17,106,18,'dcuc']
, [188,32,188,33,'dcuc']
, [189,17,189,59,'dcuc']
, [190,13,190,14,'dcuc']
, [231,70,231,114,'dcuc']
, [233,14,233,33,'dcuc']
, [233,34,233,35,'dcuc']
, [234,17,234,55,'dcuc']
, [235,13,235,14,'dcuc']
, [266,21,266,66,'dcuc']
, [267,21,267,27,'dcuc']
, [272,53,272,54,'dcuc']
, [273,25,273,51,'dcuc']
, [273,52,273,72,'dcuc']
, [274,21,274,22,'dcuc']
, [291,21,291,66,'dcuc']
, [292,21,292,27,'dcuc']
, [331,40,331,41,'dcuc']
, [332,13,332,39,'dcuc']
, [332,40,332,60,'dcuc']
, [333,9,333,10,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src110" class="dotCoverSource"><pre>// &lt;copyright file=&quot;PirateClient.cs&quot;&gt;
//      ahal@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      A network client for the PirateSpades game.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;

namespace PirateSpades.Network {
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Diagnostics.Contracts;
    using System.Net.Sockets;

    using PirateSpades.GameLogic;

    /// &lt;summary&gt;
    /// A network client for the PirateSpades game.
    /// &lt;/summary&gt;
    public class PirateClient : Player {
        /// &lt;summary&gt;
        /// The socket to use for communicating.
        /// &lt;/summary&gt;
        public Socket Socket { get; private set; }

        /// &lt;summary&gt;
        /// The buffer to use for messages.
        /// &lt;/summary&gt;
        public int BufferSize { get; private set; }

        /// &lt;summary&gt;
        /// Whether or not debug mode is in use.
        /// &lt;/summary&gt;
        public bool DebugMode { get; set; }

        /// &lt;summary&gt;
        /// Whether or not the client is a virtual player.
        /// &lt;/summary&gt;
        public bool VirtualPlayer { get; private set; }

        /// &lt;summary&gt;
        /// Whether or not the client is dead.
        /// &lt;/summary&gt;
        public bool IsDead { get; private set; }

        /// &lt;summary&gt;
        /// Delegate to be used for events involving PirateClient.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pclient&quot;&gt;The PirateClient.&lt;/param&gt;
        public delegate void PirateClientDelegate(PirateClient pclient);

        /// &lt;summary&gt;
        /// Fires when the client has been disconnected.
        /// &lt;/summary&gt;
        public event PirateClientDelegate Disconnected;

        /// &lt;summary&gt;
        /// Fires when a name request was received.
        /// &lt;/summary&gt;
        public event PirateClientDelegate NameRequested;

        /// &lt;summary&gt;
        /// Fires when a bet request was received.
        /// &lt;/summary&gt;
        public event PirateClientDelegate BetRequested;

        /// &lt;summary&gt;
        /// Fires when card request was received.
        /// &lt;/summary&gt;
        public event PirateClientDelegate CardRequested;

        /// &lt;summary&gt;
        /// A collection of socket errors to ignore.
        /// &lt;/summary&gt;
        private static readonly HashSet&lt;SocketError&gt; IgnoreSocketErrors = new HashSet&lt;SocketError&gt;() { SocketError.ConnectionReset };

        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;socket&quot;&gt;The name of the player.&lt;/param&gt;
        public PirateClient (Socket socket) : base(&quot;&quot;) {
            Contract.Requires(socket != null);
            this.Socket = socket;
            this.VirtualPlayer = true;
            this.Init();
        }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the player.&lt;/param&gt;
        /// &lt;param name=&quot;ip&quot;&gt;The ip to connect to.&lt;/param&gt;
        /// &lt;param name=&quot;port&quot;&gt;The port to use.&lt;/param&gt;
        public PirateClient(string name, IPAddress ip, int port) : base(name) {
            Contract.Requires(name != null &amp;&amp; ip != null &amp;&amp; port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; PirateScanner.IsValidIp(ip));
            this.VirtualPlayer = false;
            this.Init();
            this.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            try {
                this.Socket.Connect(ip, port);
                if(this.Socket.Connected) {
                    this.SocketMessageReceive();
                }else {
                    IsDead = true;
                }
            } catch(SocketException ex) {
                Console.WriteLine(&quot;Failed to connect: &quot; + ex);
                IsDead = true;
            }
        }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the player.&lt;/param&gt;
        /// &lt;param name=&quot;ip&quot;&gt;The ip to connect to.&lt;/param&gt;
        /// &lt;param name=&quot;port&quot;&gt;The port to use.&lt;/param&gt;
        public PirateClient (string name, string ip, int port) : this(name, IPAddress.Parse(ip), port) {
            Contract.Requires(name != null &amp;&amp; ip != null &amp;&amp; port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; PirateScanner.IsValidIp(ip));
        }

        /// &lt;summary&gt;
        /// Initialize the client.
        /// &lt;/summary&gt;
        private void Init() {
            IsDead = false;
            BufferSize = PirateMessage.BufferSize;
            if (!VirtualPlayer) {
                this.CardPlayed += this.OnCardPlayed;
                this.CardDealt += this.OnCardDealt;
                this.BetSet += this.OnBetSet;
            }
        }

        /// &lt;summary&gt;
        /// Initialize the connection to the host.
        /// &lt;/summary&gt;
        public void InitConnection() {
            PirateClientCommands.InitConnection(this);
        }

        /// &lt;summary&gt;
        /// Disconnect.
        /// &lt;/summary&gt;
        public void Disconnect() {
            if(this.Socket.Connected) {
                this.Socket.Close();
                IsDead = true;
            }
            if(Disconnected != null) {
                Disconnected(this);
            }
        }

        /// &lt;summary&gt;
        /// When a card has been played.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;The card played.&lt;/param&gt;
        private void OnCardPlayed(Card card) {
            PirateClientCommands.PlayCard(this, card);
        }

        /// &lt;summary&gt;
        /// When a card has been dealt.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;p&quot;&gt;Receiving player.&lt;/param&gt;
        /// &lt;param name=&quot;c&quot;&gt;Card dealt.&lt;/param&gt;
        private void OnCardDealt(Player p, Card c) {
            PirateClientCommands.DealCard(this, p, c);
        }

        /// &lt;summary&gt;
        /// When a bet has been set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;bet&quot;&gt;The bet.&lt;/param&gt;
        private void OnBetSet(int bet) {
            PirateClientCommands.SetBet(this, bet);
        }

        /// &lt;summary&gt;
        /// When the name has been set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name.&lt;/param&gt;
        public void SetName(string name) {
            Contract.Requires(name != null);
            this.Name = name;
            if(!VirtualPlayer) {
                PirateClientCommands.SendPlayerInfo(this);
            }
        }

        /// &lt;summary&gt;
        /// Receive socket messages asynchronously.
        /// &lt;/summary&gt;
        private void SocketMessageReceive() {
            var mobj = new PirateMessageObj(this);
            Socket.BeginReceive(
                    mobj.Buffer,
                    0,
                    mobj.Buffer.Length,
                    SocketFlags.None,
                    SocketMessageReceived,
                    mobj
            );
        }

        /// &lt;summary&gt;
        /// When a message was received through the socket.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ar&quot;&gt;AsyncResult containing information about the asynchronous operation.&lt;/param&gt;
        private void SocketMessageReceived(IAsyncResult ar) {
            Contract.Requires(ar != null &amp;&amp; ar.AsyncState is PirateMessageObj);
            try {
                var mobj = (PirateMessageObj)ar.AsyncState;

                if (Socket.Connected) {
                    var read = Socket.EndReceive(ar);

                    if (read &gt;= 4) {
                        foreach (var msg in PirateMessage.GetMessages(mobj.Buffer, read)) {
                            this.HandleMessage(msg);
                        }
                    } else if (read == 0) {
                        this.Disconnect();
                    }

                    if (Socket.Connected) SocketMessageReceive();
                }
            }catch(SocketException ex) {
                if(!IgnoreSocketErrors.Contains(ex.SocketErrorCode)) Console.WriteLine(&quot;SocketException: &quot; + ex);
                this.Disconnect();
            }catch(Exception ex) {
                Console.WriteLine(&quot;Exception: &quot; + ex);
            }
        }

        /// &lt;summary&gt;
        /// Send socket message asynchronously.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message to send.&lt;/param&gt;
        public void SendMessage(PirateMessage msg) {
            Contract.Requires(msg != null);
            var buffer = msg.GetBytes();
            Socket.BeginSend(buffer, 0, buffer.Length, SocketFlags.None, MessageSent, msg);
        }

        /// &lt;summary&gt;
        /// When a message has been sent.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ar&quot;&gt;AsyncResult containing information about the asynchronous operation.&lt;/param&gt;
        private void MessageSent(IAsyncResult ar) {
            Contract.Requires(ar != null &amp;&amp; ar.AsyncState is PirateMessage);
            var sent = Socket.EndSend(ar);
            var msg = (PirateMessage)ar.AsyncState;
            // TODO: Log that the message has been sent?
        }

        /// &lt;summary&gt;
        /// Handle the incoming message.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;msg&quot;&gt;The message.&lt;/param&gt;
        private void HandleMessage(PirateMessage msg) {
            switch(msg.Head) {
                case PirateMessageHead.Erro:
                    PirateClientCommands.ErrorMessage(this, msg);
                    break;
                case PirateMessageHead.Init:
                    PirateClientCommands.VerifyConnection(this, msg);
                    break;
                case PirateMessageHead.Pnfo:
                    if (string.IsNullOrEmpty(Name)) {
                        if (NameRequested != null) NameRequested(this);
                    } else {
                        PirateClientCommands.SendPlayerInfo(this);
                    }
                    break;
                case PirateMessageHead.Xcrd:
                    PirateClientCommands.GetCard(this, msg);
                    break;
                case PirateMessageHead.Pcrd:
                    PirateClientCommands.GetPlayedCard(this, msg);
                    break;
                case PirateMessageHead.Pigm:
                    PirateClientCommands.GetPlayersInGame(this, msg);
                    break;
                case PirateMessageHead.Gstr:
                    PirateClientCommands.GameStarted(this, msg);
                    break;
                case PirateMessageHead.Gfin:
                    PirateClientCommands.GameFinished(this, msg);
                    break;
                case PirateMessageHead.Trdn:
                    PirateClientCommands.NewPile(this, msg);
                    break;
                case PirateMessageHead.Nrnd:
                    PirateClientCommands.NewRound(this, msg);
                    break;
                case PirateMessageHead.Bgrn:
                    PirateClientCommands.BeginRound(this, msg);
                    break;
                case PirateMessageHead.Frnd:
                    PirateClientCommands.FinishRound(this, msg);
                    break;
                case PirateMessageHead.Breq:
                    this.RequestBet();
                    break;
                case PirateMessageHead.Creq:
                    this.RequestCard();
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Request bet.
        /// &lt;/summary&gt;
        public void RequestBet() {
            if(BetRequested != null) BetRequested(this);
        }

        /// &lt;summary&gt;
        /// Request card.
        /// &lt;/summary&gt;
        public void RequestCard() {
            if (CardRequested != null) CardRequested(this);
        }

        /// &lt;summary&gt;
        /// Name not available.
        /// &lt;/summary&gt;
        public void NameNotAvailable() {
            if (NameRequested != null) NameRequested(this);
        }

        public override string ToString() {
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return PirateMessage.ConstructPlayerName(Name);
        } 
    }
}
</pre></code><script type="text/javascript">
			applyranges('src110', RANGES_110)
		</script>
	</body>
</html>