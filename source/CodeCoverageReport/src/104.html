<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_104 = [
   [27,13,27,97,'dccv']
, [27,13,27,97,'dccv']
, [28,13,28,101,'dccv']
, [28,13,28,101,'dccv']
, [26,9,26,48,'dccv']
, [26,49,26,50,'dccv']
, [29,13,29,30,'dccv']
, [30,13,30,32,'dccv']
, [31,9,31,10,'dccv']
, [200,13,200,102,'dccv']
, [199,13,199,98,'dccv']
, [200,13,200,102,'dccv']
, [200,13,200,102,'dccv']
, [199,13,199,98,'dccv']
, [200,13,200,102,'dccv']
, [200,13,200,102,'dccv']
, [200,13,200,102,'dccv']
, [200,13,200,102,'dccv']
, [199,13,199,98,'dccv']
, [198,40,198,41,'dccv']
, [199,13,199,98,'dccv']
, [199,13,199,98,'dccv']
, [198,40,198,41,'dccv']
, [199,13,199,98,'dccv']
, [199,13,199,98,'dccv']
, [199,13,199,98,'dccv']
, [199,13,199,98,'dccv']
, [52,42,52,43,'dccv']
, [54,13,54,46,'dccv']
, [55,13,55,40,'dccv']
, [56,13,56,40,'dccv']
, [58,13,58,23,'dccv']
, [58,24,58,33,'dccv']
, [59,13,59,23,'dccv']
, [59,24,59,34,'dccv']
, [60,13,60,22,'dccv']
, [61,9,61,10,'dccv']
, [53,13,53,91,'dccv']
, [53,13,53,91,'dccv']
, [71,13,71,45,'dccv']
, [70,43,70,44,'dccv']
, [72,13,72,57,'dccv']
, [72,58,72,70,'dccv']
, [73,13,73,56,'dccv']
, [73,57,73,69,'dccv']
, [74,13,74,26,'dccv']
, [75,9,75,10,'dccv']
, [84,13,84,45,'dccv']
, [83,41,83,42,'dccv']
, [85,13,85,38,'dccv']
, [86,9,86,10,'dccv']
, [93,43,93,44,'dccv']
, [95,13,95,72,'dccv']
, [96,9,96,10,'dccv']
, [94,13,94,65,'dccv']
, [103,39,103,40,'dccv']
, [104,13,104,28,'dccv']
, [105,13,105,25,'dccv']
, [107,21,107,32,'dccv']
, [108,21,108,27,'dccv']
, [110,21,110,32,'dccv']
, [111,21,111,27,'dccv']
, [113,21,113,32,'dccv']
, [114,21,114,27,'dccv']
, [117,13,117,49,'dccv']
, [118,13,118,26,'dccv']
, [120,21,120,33,'dccv']
, [121,21,121,27,'dccv']
, [123,21,123,33,'dccv']
, [124,21,124,27,'dccv']
, [126,21,126,33,'dccv']
, [127,21,127,27,'dccv']
, [129,21,129,33,'dccv']
, [130,21,130,27,'dccv']
, [132,21,132,33,'dccv']
, [133,21,133,27,'dccv']
, [136,13,136,33,'dccv']
, [137,9,137,10,'dccv']
, [146,13,146,42,'dccv']
, [147,13,147,165,'dccv']
, [145,49,145,50,'dccv']
, [149,13,149,152,'dccv']
, [150,13,150,81,'dccv']
, [151,13,151,92,'dccv']
, [152,13,152,42,'dccv']
, [153,9,153,10,'dccv']
, [148,13,148,63,'dccv']
, [163,13,163,57,'dccv']
, [163,13,163,57,'dccv']
, [162,63,162,64,'dccv']
, [164,13,164,66,'dccv']
, [165,13,165,82,'dccv']
, [166,9,166,10,'dccv']
, [173,43,173,44,'dccv']
, [174,13,174,63,'dccv']
, [175,13,175,22,'dccv']
, [176,9,176,10,'dccv']
, [211,13,211,87,'dccv']
, [211,13,211,87,'dccv']
, [210,61,210,62,'dccv']
, [212,13,212,49,'dccv']
, [213,13,213,48,'dccv']
, [214,17,214,27,'dccv']
, [214,51,214,52,'dccv']
, [215,17,215,49,'dccv']
, [216,13,216,14,'dccv']
, [214,46,214,49,'dccv']
, [214,28,214,44,'dccv']
, [217,13,217,54,'dccv']
, [218,9,218,10,'dccv']
, [198,40,198,41,'dccv']
, [199,13,199,98,'dccv']
, [199,13,199,98,'dccv']
, [200,13,200,102,'dccv']
, [200,13,200,102,'dccv']
, [199,13,199,98,'dcuc']
, [200,13,200,102,'dcuc']
, [200,13,200,102,'dcuc']
, [199,13,199,98,'dcuc']
, [200,13,200,102,'dcuc']
, [198,40,198,41,'dcuc']
, [199,13,199,98,'dcuc']
, [199,13,199,98,'dcuc']
, [198,40,198,41,'dcuc']
, [199,13,199,98,'dcuc']
, [54,47,54,56,'dcuc']
, [184,49,184,50,'dcuc']
, [185,13,185,32,'dcuc']
, [185,33,185,34,'dcuc']
, [186,17,186,30,'dcuc']
, [188,13,188,57,'dcuc']
, [188,58,188,59,'dcuc']
, [189,17,189,30,'dcuc']
, [191,13,191,42,'dcuc']
, [191,43,191,44,'dcuc']
, [192,17,192,30,'dcuc']
, [194,13,194,52,'dcuc']
, [195,9,195,10,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src104" class="dotCoverSource"><pre>// &lt;copyright file=&quot;Card.cs&quot;&gt;
//      ahal@itu.dk,
//      mche@itu.dk
// &lt;/copyright&gt;
// &lt;summary&gt;
//      A representation of a card in the Pirate Spades Game.
// &lt;/summary&gt;
// &lt;author&gt;Andreas Hallberg Kjeldsen (ahal@itu.dk)&lt;/author&gt;
// &lt;author&gt;Morten Charbert Eskesen (mche@itu.dk)&lt;/author&gt;

namespace PirateSpades.GameLogic {
    using System.Diagnostics.Contracts;
    using System;
    using System.Text.RegularExpressions;

    /// &lt;summary&gt;
    /// A representation of a card in the Pirate Spades Game.
    /// &lt;/summary&gt;
    public class Card : IComparable {

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;suit&quot;&gt;The suit of the card.&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value of the card.&lt;/param&gt;
        public Card(Suit suit, CardValue value) {
            Contract.Requires((int)suit &gt;= (int)Suit.Diamonds &amp;&amp; (int)suit &lt;= (int)Suit.Spades);
            Contract.Requires((int)value &gt;= (int)CardValue.Two &amp;&amp; (int)value &lt;= (int)CardValue.Ace);
            this.Suit = suit;
            this.Value = value;
        }

        /// &lt;summary&gt;
        /// The value of the card.
        /// &lt;/summary&gt;
        public CardValue Value { get; private set; }

        /// &lt;summary&gt;
        /// The suit of the card.
        /// &lt;/summary&gt;
        public Suit Suit { get; private set; }

        /// &lt;summary&gt;
        /// Compares an object to the current card.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;obj&quot;&gt;The object to compare.&lt;/param&gt;
        /// &lt;returns&gt;
        /// 0 if the object is not of type Card or if they are of the same value, 
        /// -1 if the current card is higher than the obj and 1 if the object is higher.
        /// &lt;/returns&gt;
        [Pure]
        public int CompareTo(Object obj) {
            Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= -1 &amp;&amp; Contract.Result&lt;int&gt;() &lt;= 1);
            if(obj == null || !(obj is Card)) return 0;
            var h = this.GetHashCode();
            var oh = obj.GetHashCode();

            if(h &gt; oh) return 1;
            if(h &lt; oh) return -1;
            return 0;
        }

        /// &lt;summary&gt;
        /// Checks whether the specified card is higher than the current card.
        /// Spades are trump.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;The card to check.&lt;/param&gt;
        /// &lt;returns&gt;True if the card is higher, false if not.&lt;/returns&gt;
        [Pure]
        public bool HigherThan(Card card) {
            Contract.Requires(card != null);
            if(Suit == Suit.Spades &amp;&amp; card.Suit != Suit) return true;
            if(Suit == card.Suit &amp;&amp; Value &gt; card.Value) return true;
            return false;
        }

        /// &lt;summary&gt;
        /// Checks whether the specified card is of the same suit as the current.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;The card to check.&lt;/param&gt;
        /// &lt;returns&gt;True if they are of the same suit, false if not.&lt;/returns&gt;
        [Pure]
        public bool SameSuit(Card card) {
            Contract.Requires(card != null);
            return Suit == card.Suit;
        }

        /// &lt;summary&gt;
        /// Get a textual represenation of the card.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A string representing the card.&lt;/returns&gt;
        [Pure]
        public override string ToString() {
            Contract.Ensures(Contract.Result&lt;string&gt;() != null);
            return &quot;card: &quot; + Suit.ToString() + &quot;;&quot; + Value.ToString();
        }

        /// &lt;summary&gt;
        /// Get a cute and small textual representation of the card.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A string representing the card.&lt;/returns&gt;
        [Pure]
        public string ToShortString() {
            var suit = &quot;♥&quot;;
            switch(Suit) {
                case Suit.Clubs:
                    suit = &quot;♣&quot;;
                    break;
                case Suit.Diamonds:
                    suit = &quot;♦&quot;;
                    break;
                case Suit.Spades:
                    suit = &quot;♠&quot;;
                    break;
            }

            var value = ((int)Value).ToString();
            switch(Value) {
                case CardValue.Ten:
                    value = &quot;T&quot;;
                    break;
                case CardValue.Jack:
                    value = &quot;J&quot;;
                    break;
                case CardValue.Queen:
                    value = &quot;Q&quot;;
                    break;
                case CardValue.King:
                    value = &quot;K&quot;;
                    break;
                case CardValue.Ace:
                    value = &quot;A&quot;;
                    break;
            }

            return suit + value;
        }

        /// &lt;summary&gt;
        /// Get a card from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;The string to get the card from.&lt;/param&gt;
        /// &lt;returns&gt;The card.&lt;/returns&gt;
        [Pure]
        public static Card FromString(string s) {
            Contract.Requires(s != null);
            Contract.Requires(Regex.IsMatch(s, &quot;^card: &quot; + EnumRegexString(typeof(Suit)) + &quot;;&quot; + EnumRegexString(typeof(CardValue)) + &quot;$&quot;, RegexOptions.Multiline));
            Contract.Ensures(Contract.Result&lt;Card&gt;() != null);
            var m = Regex.Match(s, &quot;^card: &quot; + EnumRegexString(typeof(Suit)) + &quot;;&quot; + EnumRegexString(typeof(CardValue)) + &quot;$&quot;, RegexOptions.Multiline);
            var suit = (Suit) Enum.Parse(typeof(Suit), m.Groups[1].Value, true);
            var value = (CardValue) Enum.Parse(typeof(CardValue), m.Groups[2].Value, true);
            return new Card(suit, value);
        }

        /// &lt;summary&gt;
        /// Get amount of cards to deal per player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;round&quot;&gt;The round number.&lt;/param&gt;
        /// &lt;param name=&quot;players&quot;&gt;Amount of players.&lt;/param&gt;
        /// &lt;returns&gt;Amount of cards to deal per player.&lt;/returns&gt;
        [Pure]
        public static int CardsToDeal(int round, int players) {
            Contract.Requires(round &gt; 0 &amp;&amp; players &gt; 0);
            var maxCards = 52 / players &lt; 10 ? 52 / players : 10;
            return (round &lt;= maxCards ? maxCards - round + 1 : round - maxCards);
        }

        /// &lt;summary&gt;
        /// Get the hash code of the card.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The hash code of the card.&lt;/returns&gt;
        [Pure]
        public override int GetHashCode() {
            var h = (int)Math.Pow(10, (int)Suit) + (int)Value;
            return h;
        }

        /// &lt;summary&gt;
        /// Checks whether or not the specified object equals this.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;obj&quot;&gt;The object to check.&lt;/param&gt;
        /// &lt;returns&gt;True if they&#39;re equal, false if not.&lt;/returns&gt;
        [Pure]
        public override bool Equals(object obj) {
            if (!(obj is Card)) {
                return false;
            }
            if (obj.GetHashCode() != this.GetHashCode()) {
                return false;
            }
            if (((Card)obj).Suit != Suit) {
                return false;
            }
            return ((Card)obj).Value == this.Value;
        }

        [ContractInvariantMethod]
        private void ObjectInvariant() {
            Contract.Invariant((int)Suit &gt;= (int)Suit.Diamonds &amp;&amp; (int)Suit &lt;= (int)Suit.Spades);
            Contract.Invariant((int)Value &gt;= (int)CardValue.Two &amp;&amp; (int)Value &lt;= (int)CardValue.Ace);
        }

        /// &lt;summary&gt;
        /// Get a string for use with regex of all the specified enums possible textual values.
        /// Example: (Diamonds|Clubs|Hearts|Spades)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;enumType&quot;&gt;The enum to use.&lt;/param&gt;
        /// &lt;returns&gt;The regex string.&lt;/returns&gt;
        [Pure]
        public static string EnumRegexString(Type enumType) {
            Contract.Requires(enumType != null &amp;&amp; Enum.GetNames(enumType).Length &gt; 0);
            var names = Enum.GetNames(enumType);
            var res = new string[names.Length];
            for(var i = 0; i &lt; names.Length; i++) {
                res[i] = Regex.Escape(names[i]);
            }
            return &quot;(&quot; + string.Join(&quot;|&quot;, res) + &quot;)&quot;;
        }
    }

    public enum Suit {
        /// &lt;summary&gt;Diamonds&lt;/summary&gt;
        Diamonds = 1,

        /// &lt;summary&gt;Clubs&lt;/summary&gt;
        Clubs = 2,

        /// &lt;summary&gt;Hearts&lt;/summary&gt;
        Hearts = 3,

        /// &lt;summary&gt;Spades&lt;/summary&gt;
        Spades = 4
    }

    public enum CardValue {
        /// &lt;summary&gt;Two&lt;/summary&gt;
        Two = 2,

        /// &lt;summary&gt;Three&lt;/summary&gt;
        Three = 3,

        /// &lt;summary&gt;Four&lt;/summary&gt;
        Four = 4,

        /// &lt;summary&gt;Five&lt;/summary&gt;
        Five = 5,

        /// &lt;summary&gt;Six&lt;/summary&gt;
        Six = 6,

        /// &lt;summary&gt;Seven&lt;/summary&gt;
        Seven = 7,

        /// &lt;summary&gt;Eight&lt;/summary&gt;
        Eight = 8,

        /// &lt;summary&gt;Nine&lt;/summary&gt;
        Nine = 9,

        /// &lt;summary&gt;Ten&lt;/summary&gt;
        Ten = 10,

        /// &lt;summary&gt;Jack&lt;/summary&gt;
        Jack = 11,

        /// &lt;summary&gt;Queen&lt;/summary&gt;
        Queen = 12,

        /// &lt;summary&gt;King&lt;/summary&gt;
        King = 13,

        /// &lt;summary&gt;Ace&lt;/summary&gt;
        Ace = 14
    }
}
</pre></code><script type="text/javascript">
			applyranges('src104', RANGES_104)
		</script>
	</body>
</html>